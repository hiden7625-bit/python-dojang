<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sky Fighter - Ïä§Ïπ¥Ïù¥ ÌååÏù¥ÌÑ∞</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: hidden;
  font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
  user-select: none;
}
#gameCanvas {
  display: block;
  image-rendering: pixelated;
}
#ui-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#start-screen, #gameover-screen {
  pointer-events: auto;
  text-align: center;
  color: #fff;
  padding: 40px;
  border-radius: 20px;
  background: rgba(0,0,0,0.85);
  border: 2px solid rgba(100,180,255,0.3);
  backdrop-filter: blur(10px);
  max-width: 420px;
}
#start-screen h1 {
  font-size: 42px;
  font-weight: 800;
  background: linear-gradient(135deg, #00d2ff, #3a7bd5, #ff6b6b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 10px;
  letter-spacing: -1px;
}
#start-screen .subtitle {
  font-size: 14px;
  color: #8ab4f8;
  margin-bottom: 30px;
}
#gameover-screen h2 {
  font-size: 36px;
  color: #ff6b6b;
  margin-bottom: 10px;
}
#gameover-screen .final-score {
  font-size: 48px;
  font-weight: 800;
  color: #ffd700;
  margin: 15px 0;
}
.btn {
  display: inline-block;
  padding: 14px 48px;
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  background: linear-gradient(135deg, #3a7bd5, #00d2ff);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s;
  letter-spacing: 1px;
  margin-top: 15px;
}
.btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0,210,255,0.4); }
.controls-info {
  margin-top: 25px;
  font-size: 12px;
  color: #7a8ba8;
  line-height: 1.8;
}
.controls-info kbd {
  display: inline-block;
  padding: 2px 8px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  font-family: monospace;
  font-size: 11px;
  color: #aac;
}
#hud {
  position: absolute;
  top: 0; left: 0; right: 0;
  padding: 10px 16px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  pointer-events: none;
  z-index: 10;
}
#hud-left, #hud-right { display: flex; flex-direction: column; gap: 4px; }
#hud-left { align-items: flex-start; }
#hud-right { align-items: flex-end; }
.hud-label {
  font-size: 11px;
  color: #5a7a9a;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.hud-value {
  font-size: 22px;
  font-weight: 800;
  color: #fff;
  text-shadow: 0 0 10px rgba(0,200,255,0.5);
}
.hud-value.score { color: #ffd700; }
.hud-lives { display: flex; gap: 4px; margin-top: 2px; }
.hud-lives span { font-size: 18px; }
.hud-bombs { display: flex; gap: 3px; margin-top: 2px; }
.hud-bombs span { font-size: 16px; }
.hud-weapon {
  font-size: 13px;
  font-weight: 600;
  color: #4af;
  margin-top: 2px;
}
#mobile-controls {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  padding: 20px;
  display: none;
  justify-content: space-between;
  align-items: flex-end;
  pointer-events: auto;
  z-index: 20;
}
.mobile-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: rgba(255,255,255,0.12);
  border: 2px solid rgba(255,255,255,0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  color: rgba(255,255,255,0.7);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.mobile-btn:active { background: rgba(255,255,255,0.3); }
.mobile-btn.bomb-btn {
  background: rgba(255,80,80,0.2);
  border-color: rgba(255,80,80,0.4);
  font-size: 22px;
}
.dpad {
  display: grid;
  grid-template-columns: 56px 56px 56px;
  grid-template-rows: 56px 56px 56px;
  gap: 4px;
}
.dpad .mobile-btn { width: 56px; height: 56px; font-size: 22px; }
.dpad-up { grid-column: 2; grid-row: 1; }
.dpad-down { grid-column: 2; grid-row: 3; }
.dpad-left { grid-column: 1; grid-row: 2; }
.dpad-right { grid-column: 3; grid-row: 2; }
.hidden { display: none !important; }
@media (pointer: coarse) {
  #mobile-controls { display: flex; }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="hud" class="hidden">
  <div id="hud-left">
    <span class="hud-label">Score</span>
    <span class="hud-value score" id="hud-score">0</span>
    <span class="hud-label" style="margin-top:6px">Lives</span>
    <div class="hud-lives" id="hud-lives"></div>
  </div>
  <div id="hud-right">
    <span class="hud-label">Weapon</span>
    <span class="hud-weapon" id="hud-weapon">LV.1 Í∏∞Î≥∏ Í∏∞Í¥ÄÌè¨</span>
    <span class="hud-label" style="margin-top:6px">Î¨¥Ï†Å Ìè≠ÌÉÑ</span>
    <div class="hud-bombs" id="hud-bombs"></div>
  </div>
</div>

<div id="ui-overlay">
  <div id="start-screen">
    <h1>SKY FIGHTER</h1>
    <div class="subtitle">Ïä§Ïπ¥Ïù¥ ÌååÏù¥ÌÑ∞ - ÌïòÎäòÏùò Ï†ÑÏÇ¨</div>
    <button class="btn" id="btn-start">Í≤åÏûÑ ÏãúÏûë</button>
    <div class="controls-info">
      <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> <kbd>‚Üë</kbd> <kbd>‚Üì</kbd> Ïù¥Îèô &nbsp;|&nbsp;
      <kbd>Space</kbd> ÏÇ¨Í≤© (ÏûêÎèô)<br>
      <kbd>B</kbd> Î¨¥Ï†Å Ìè≠ÌÉÑ &nbsp;|&nbsp; Î™®Î∞îÏùº: ÌÑ∞Ïπò Î≤ÑÌäº
    </div>
  </div>
  <div id="gameover-screen" class="hidden">
    <h2>GAME OVER</h2>
    <div>ÏµúÏ¢Ö Ï†êÏàò</div>
    <div class="final-score" id="final-score">0</div>
    <div id="final-stats" style="font-size:13px;color:#8ab4f8;margin-bottom:10px;"></div>
    <button class="btn" id="btn-restart">Îã§Ïãú ÏãúÏûë</button>
  </div>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div class="mobile-btn dpad-up" data-dir="up">‚ñ≤</div>
    <div class="mobile-btn dpad-left" data-dir="left">‚óÄ</div>
    <div class="mobile-btn dpad-right" data-dir="right">‚ñ∂</div>
    <div class="mobile-btn dpad-down" data-dir="down">‚ñº</div>
  </div>
  <div style="display:flex;gap:12px;align-items:flex-end;">
    <div class="mobile-btn bomb-btn" id="mobile-bomb">üí£</div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}
resize();
window.addEventListener('resize', resize);

// Game state
const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
let gameState = STATE.MENU;
let score = 0;
let highScore = parseInt(localStorage.getItem('skyFighterHigh') || '0');
let kills = 0;
let gameTime = 0;
let difficulty = 1;

// Input
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Mobile input
const mobileDir = { up: false, down: false, left: false, right: false };
document.querySelectorAll('.dpad .mobile-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  const start = () => { mobileDir[dir] = true; };
  const end = () => { mobileDir[dir] = false; };
  btn.addEventListener('touchstart', e => { e.preventDefault(); start(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); end(); });
  btn.addEventListener('touchcancel', e => { end(); });
});
document.getElementById('mobile-bomb').addEventListener('touchstart', e => { e.preventDefault(); useBomb(); });

// Stars background
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    size: Math.random() * 2 + 0.5,
    speed: Math.random() * 2 + 0.5,
    brightness: Math.random() * 0.5 + 0.5
  });
}

// Clouds
const clouds = [];
for (let i = 0; i < 8; i++) {
  clouds.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    w: Math.random() * 200 + 100,
    h: Math.random() * 40 + 20,
    speed: Math.random() * 0.5 + 0.3,
    alpha: Math.random() * 0.04 + 0.02
  });
}

// Player
let player;
function initPlayer() {
  player = {
    x: W / 2,
    y: H - 120,
    w: 40,
    h: 48,
    speed: 5,
    lives: 3,
    weaponLevel: 1,
    bombs: 5,
    invincible: false,
    invincibleTimer: 0,
    fireRate: 150,
    fireTimer: 0,
    engineFlicker: 0,
    tilt: 0,
    shieldPulse: 0
  };
}

// Bullets
let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let items = [];
let explosions = [];
let screenShake = 0;
let bombFlash = 0;
let damageFlash = 0;

// Enemy spawn timer
let enemySpawnTimer = 0;
let enemySpawnRate = 1200;
let waveCount = 0;

// Weapon definitions
const WEAPONS = {
  1: { name: 'LV.1 Í∏∞Î≥∏ Í∏∞Í¥ÄÌè¨', fireRate: 170, color: '#4af', damage: 1 },
  2: { name: 'LV.2 ÎçîÎ∏î Ï∫êÎÖº', fireRate: 145, color: '#4fc', damage: 1.8 },
  3: { name: 'LV.3 Ìä∏Î¶¨Ìîå Ï∫êÎÖº', fireRate: 120, color: '#fa4', damage: 2.8 },
  4: { name: 'LV.4 Ïä§ÌîÑÎ†àÎìú Ï∫êÎÖº', fireRate: 95, color: '#f64', damage: 4 },
  5: { name: 'LV.MAX Î©îÍ∞Ä Ï∫êÎÖº', fireRate: 75, color: '#ff4', damage: 6 }
};

function fireBullets() {
  const w = WEAPONS[player.weaponLevel];
  const cx = player.x;
  const cy = player.y - player.h / 2;
  const bSpeed = 10 + player.weaponLevel * 0.8;

  switch (player.weaponLevel) {
    case 1:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      break;
    case 2:
      bullets.push({ x: cx - 10, y: cy, vx: 0, vy: -bSpeed, w: 5, h: 16, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 10, y: cy, vx: 0, vy: -bSpeed, w: 5, h: 16, color: w.color, damage: w.damage });
      break;
    case 3:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 6, h: 20, color: '#fff', damage: w.damage * 1.2 });
      bullets.push({ x: cx - 14, y: cy + 6, vx: -1.8, vy: -bSpeed, w: 5, h: 16, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 14, y: cy + 6, vx: 1.8, vy: -bSpeed, w: 5, h: 16, color: w.color, damage: w.damage });
      break;
    case 4:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 7, h: 22, color: '#fff', damage: w.damage * 1.3 });
      bullets.push({ x: cx - 13, y: cy + 4, vx: -1.4, vy: -bSpeed, w: 5, h: 18, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 13, y: cy + 4, vx: 1.4, vy: -bSpeed, w: 5, h: 18, color: w.color, damage: w.damage });
      bullets.push({ x: cx - 24, y: cy + 10, vx: -3, vy: -bSpeed * 0.9, w: 4, h: 14, color: w.color, damage: w.damage * 0.8 });
      bullets.push({ x: cx + 24, y: cy + 10, vx: 3, vy: -bSpeed * 0.9, w: 4, h: 14, color: w.color, damage: w.damage * 0.8 });
      break;
    case 5:
      // Center mega beam
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed * 1.1, w: 9, h: 26, color: '#fff', damage: w.damage * 1.5 });
      // Inner spread
      bullets.push({ x: cx - 10, y: cy + 3, vx: -1, vy: -bSpeed, w: 6, h: 20, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 10, y: cy + 3, vx: 1, vy: -bSpeed, w: 6, h: 20, color: w.color, damage: w.damage });
      // Outer spread
      bullets.push({ x: cx - 22, y: cy + 8, vx: -2.5, vy: -bSpeed * 0.92, w: 5, h: 16, color: w.color, damage: w.damage * 0.8 });
      bullets.push({ x: cx + 22, y: cy + 8, vx: 2.5, vy: -bSpeed * 0.92, w: 5, h: 16, color: w.color, damage: w.damage * 0.8 });
      // Wide flankers
      bullets.push({ x: cx - 32, y: cy + 14, vx: -4, vy: -bSpeed * 0.85, w: 4, h: 12, color: w.color, damage: w.damage * 0.6 });
      bullets.push({ x: cx + 32, y: cy + 14, vx: 4, vy: -bSpeed * 0.85, w: 4, h: 12, color: w.color, damage: w.damage * 0.6 });
      break;
  }
}

// Enemy types
function createEnemy(type) {
  const e = {
    x: Math.random() * (W - 80) + 40,
    y: -60,
    type: type || 'basic',
    hp: 1,
    maxHp: 1,
    speed: 2,
    w: 36,
    h: 36,
    score: 100,
    fireTimer: 0,
    fireRate: 0,
    movePattern: 'straight',
    moveTimer: Math.random() * Math.PI * 2,
    color: '#f55'
  };

  switch (e.type) {
    case 'basic':
      e.hp = 1; e.maxHp = 1; e.speed = 1.5 + difficulty * 0.3;
      e.score = 100; e.color = '#e74c3c'; e.w = 32; e.h = 32;
      break;
    case 'fast':
      e.hp = 1; e.maxHp = 1; e.speed = 3 + difficulty * 0.4;
      e.score = 150; e.color = '#e67e22'; e.w = 28; e.h = 28;
      e.movePattern = 'zigzag';
      break;
    case 'tank':
      e.hp = 3 + Math.floor(difficulty * 0.5); e.maxHp = e.hp;
      e.speed = 1 + difficulty * 0.15; e.score = 300;
      e.color = '#8e44ad'; e.w = 44; e.h = 44;
      break;
    case 'shooter':
      e.hp = 2; e.maxHp = 2; e.speed = 1.2 + difficulty * 0.2;
      e.score = 250; e.color = '#2ecc71'; e.w = 36; e.h = 36;
      e.fireRate = 1500 - difficulty * 50;
      e.fireTimer = Math.random() * 500;
      break;
    case 'boss':
      e.hp = 15 + difficulty * 5; e.maxHp = e.hp;
      e.speed = 0.6; e.score = 2000;
      e.color = '#c0392b'; e.w = 70; e.h = 60;
      e.fireRate = 800; e.fireTimer = 0;
      e.movePattern = 'boss';
      e.x = W / 2;
      e.bombHits = 0;
      break;
  }
  return e;
}

function spawnEnemies(dt) {
  enemySpawnTimer -= dt;
  if (enemySpawnTimer <= 0) {
    waveCount++;
    const roll = Math.random();
    const extraCount = Math.min(Math.floor(difficulty / 2), 4);

    if (waveCount % 20 === 0) {
      enemies.push(createEnemy('boss'));
      for (let i = 0; i < 2; i++) enemies.push(createEnemy('basic'));
    } else if (roll < 0.35) {
      const count = 2 + extraCount;
      for (let i = 0; i < count; i++) enemies.push(createEnemy('basic'));
    } else if (roll < 0.55) {
      const count = 1 + Math.floor(extraCount * 0.7);
      for (let i = 0; i < count; i++) enemies.push(createEnemy('fast'));
    } else if (roll < 0.7) {
      enemies.push(createEnemy('tank'));
      for (let i = 0; i < 1 + Math.floor(extraCount * 0.5); i++) enemies.push(createEnemy('basic'));
    } else if (roll < 0.85) {
      enemies.push(createEnemy('shooter'));
      if (difficulty > 1) enemies.push(createEnemy('basic'));
      if (difficulty > 3) enemies.push(createEnemy('shooter'));
    } else {
      enemies.push(createEnemy('fast'));
      enemies.push(createEnemy('fast'));
      enemies.push(createEnemy('basic'));
      if (difficulty > 2) enemies.push(createEnemy('shooter'));
    }
    enemySpawnRate = Math.max(200, 900 - difficulty * 70);
    enemySpawnTimer = enemySpawnRate + Math.random() * 300;
  }
}

// Items
function spawnItem(x, y) {
  const roll = Math.random();
  let type;
  if (player.weaponLevel < 5 && roll < 0.55) type = 'weapon';
  else if (roll < 0.55) type = 'score';
  else if (roll < 0.75) type = 'bomb';
  else if (roll < 0.9) type = 'score';
  else type = 'heal';

  items.push({
    x, y,
    type,
    vy: 1.5,
    w: 24, h: 24,
    pulse: 0,
    life: 600
  });
}

function useBomb() {
  if (gameState !== STATE.PLAYING || player.bombs <= 0) return;
  player.bombs--;
  player.invincible = true;
  player.invincibleTimer = 3000;
  bombFlash = 1;
  screenShake = 15;

  const surviving = [];
  enemies.forEach(e => {
    if (e.type === 'boss') {
      e.bombHits = (e.bombHits || 0) + 1;
      if (e.bombHits >= 2) {
        createExplosion(e.x, e.y, e.w);
        score += e.score;
        kills++;
        screenShake = 25;
      } else {
        e.hp = Math.ceil(e.maxHp * 0.35);
        createExplosion(e.x, e.y, e.w * 0.6);
        showFloatingText(e.x, e.y - e.h, 'Î≥¥Ïä§ ÏÉùÏ°¥! Ìè≠ÌÉÑ 1Ìöå Îçî ÌïÑÏöî!', '#ff4444');
        surviving.push(e);
      }
    } else {
      createExplosion(e.x, e.y, e.w);
      score += e.score;
      kills++;
    }
  });
  enemies = surviving;
  enemyBullets = [];

  for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 8 + 2;
    particles.push({
      x: player.x, y: player.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 60 + Math.random() * 40,
      maxLife: 100,
      size: Math.random() * 4 + 2,
      color: `hsl(${Math.random() * 60 + 30}, 100%, ${Math.random() * 30 + 60}%)`
    });
  }
  updateHUD();
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyB') useBomb();
});

function createExplosion(x, y, size) {
  explosions.push({ x, y, radius: 0, maxRadius: size * 1.5 + 20, life: 1, speed: 0.04 });
  for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 5 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      size: Math.random() * 3 + 1,
      color: `hsl(${Math.random() * 40 + 10}, 100%, ${Math.random() * 30 + 50}%)`
    });
  }
}

// Draw functions

// Shared fighter jet drawing utility
// dir: -1 = facing up (player), 1 = facing down (enemies)
function drawJet(x, y, w, h, dir, colors, flicker, opts) {
  const s = h / 48; // scale factor relative to base size 48
  const ws = w / 40;
  const d = dir;

  // Afterburner flames (behind the jet)
  const flameLen = (14 + Math.sin(flicker * 2.5) * 7) * s;
  const flameDir = -d; // flames go opposite to flight direction
  const tailY = d * (-h / 2); // tail position

  // Twin afterburner glow
  const eg1 = ctx.createRadialGradient(-8 * ws, tailY + flameDir * 6, 1, -8 * ws, tailY + flameDir * 12, 10 * s);
  eg1.addColorStop(0, colors.flameCore.replace(')', `,${flicker})`).replace('rgba', 'rgba').replace('rgb(', 'rgba('));
  eg1.addColorStop(0.5, `rgba(${colors.flameRGB},${flicker * 0.4})`);
  eg1.addColorStop(1, `rgba(${colors.flameRGB},0)`);
  ctx.fillStyle = eg1;
  ctx.fillRect(-16 * ws, tailY + Math.min(0, flameDir) * 16, 16 * ws, 16 * s);
  const eg2 = ctx.createRadialGradient(8 * ws, tailY + flameDir * 6, 1, 8 * ws, tailY + flameDir * 12, 10 * s);
  eg2.addColorStop(0, colors.flameCore.replace(')', `,${flicker})`).replace('rgba', 'rgba').replace('rgb(', 'rgba('));
  eg2.addColorStop(0.5, `rgba(${colors.flameRGB},${flicker * 0.4})`);
  eg2.addColorStop(1, `rgba(${colors.flameRGB},0)`);
  ctx.fillStyle = eg2;
  ctx.fillRect(0, tailY + Math.min(0, flameDir) * 16, 16 * ws, 16 * s);

  // Flame triangles
  ctx.beginPath();
  ctx.moveTo(-12 * ws, tailY);
  ctx.lineTo(-8 * ws, tailY + flameDir * flameLen);
  ctx.lineTo(-4 * ws, tailY);
  ctx.fillStyle = `rgba(${colors.flameRGB},${flicker * 0.85})`;
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(4 * ws, tailY);
  ctx.lineTo(8 * ws, tailY + flameDir * flameLen);
  ctx.lineTo(12 * ws, tailY);
  ctx.fillStyle = `rgba(${colors.flameRGB},${flicker * 0.85})`;
  ctx.fill();
  // Inner white-hot core
  const coreLen = flameLen * 0.55;
  ctx.beginPath();
  ctx.moveTo(-10 * ws, tailY);
  ctx.lineTo(-8 * ws, tailY + flameDir * coreLen);
  ctx.lineTo(-6 * ws, tailY);
  ctx.fillStyle = `rgba(${colors.flameCoreRGB},${flicker * 0.7})`;
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(6 * ws, tailY);
  ctx.lineTo(8 * ws, tailY + flameDir * coreLen);
  ctx.lineTo(10 * ws, tailY);
  ctx.fillStyle = `rgba(${colors.flameCoreRGB},${flicker * 0.7})`;
  ctx.fill();

  // Engine nozzles (small dark circles at tail)
  ctx.beginPath();
  ctx.arc(-8 * ws, tailY, 4 * s, 0, Math.PI * 2);
  ctx.fillStyle = colors.nozzle;
  ctx.fill();
  ctx.beginPath();
  ctx.arc(8 * ws, tailY, 4 * s, 0, Math.PI * 2);
  ctx.fillStyle = colors.nozzle;
  ctx.fill();

  const noseY = d * (h / 2); // nose tip position (direction of flight)

  // Main swept-back wings
  const wingRoot = d * (-h * 0.05);
  const wingTip = d * (h * 0.15);
  const wingBack = d * (h * 0.22);
  const wingSpan = w * 1.25;

  ctx.beginPath();
  ctx.moveTo(-7 * ws, wingRoot);
  ctx.lineTo(-wingSpan, wingTip);
  ctx.lineTo(-wingSpan * 0.88, wingBack);
  ctx.lineTo(-9 * ws, d * (h * 0.12));
  ctx.closePath();
  const wgL = ctx.createLinearGradient(-wingSpan, 0, 0, 0);
  wgL.addColorStop(0, colors.wingTip);
  wgL.addColorStop(0.6, colors.wingMid);
  wgL.addColorStop(1, colors.wingRoot);
  ctx.fillStyle = wgL;
  ctx.fill();
  ctx.strokeStyle = colors.wingEdge;
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(7 * ws, wingRoot);
  ctx.lineTo(wingSpan, wingTip);
  ctx.lineTo(wingSpan * 0.88, wingBack);
  ctx.lineTo(9 * ws, d * (h * 0.12));
  ctx.closePath();
  const wgR = ctx.createLinearGradient(0, 0, wingSpan, 0);
  wgR.addColorStop(0, colors.wingRoot);
  wgR.addColorStop(0.4, colors.wingMid);
  wgR.addColorStop(1, colors.wingTip);
  ctx.fillStyle = wgR;
  ctx.fill();
  ctx.strokeStyle = colors.wingEdge;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Horizontal stabilizers (small rear wings near tail)
  const stabRoot = d * (-h * 0.3);
  const stabTip = d * (-h * 0.2);
  const stabBack = d * (-h * 0.15);
  const stabSpan = w * 0.6;

  ctx.beginPath();
  ctx.moveTo(-8 * ws, stabRoot);
  ctx.lineTo(-stabSpan, stabTip);
  ctx.lineTo(-stabSpan * 0.85, stabBack);
  ctx.lineTo(-9 * ws, d * (-h * 0.22));
  ctx.closePath();
  ctx.fillStyle = colors.stabColor;
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(8 * ws, stabRoot);
  ctx.lineTo(stabSpan, stabTip);
  ctx.lineTo(stabSpan * 0.85, stabBack);
  ctx.lineTo(9 * ws, d * (-h * 0.22));
  ctx.closePath();
  ctx.fillStyle = colors.stabColor;
  ctx.fill();

  // Fuselage (main body)
  ctx.beginPath();
  ctx.moveTo(0, noseY + d * 4 * s);        // nose tip
  ctx.lineTo(-5 * ws, noseY - d * 6 * s);   // nose sides
  ctx.lineTo(-10 * ws, d * (h * 0.1));       // forward fuselage
  ctx.lineTo(-12 * ws, d * (-h * 0.08));     // mid fuselage
  ctx.lineTo(-10 * ws, tailY);               // rear fuselage
  ctx.lineTo(10 * ws, tailY);
  ctx.lineTo(12 * ws, d * (-h * 0.08));
  ctx.lineTo(10 * ws, d * (h * 0.1));
  ctx.lineTo(5 * ws, noseY - d * 6 * s);
  ctx.closePath();

  const bodyG = ctx.createLinearGradient(-12 * ws, 0, 12 * ws, 0);
  bodyG.addColorStop(0, colors.bodyEdge);
  bodyG.addColorStop(0.25, colors.bodyLight);
  bodyG.addColorStop(0.5, colors.bodyCenter);
  bodyG.addColorStop(0.75, colors.bodyLight);
  bodyG.addColorStop(1, colors.bodyEdge);
  ctx.fillStyle = bodyG;
  ctx.fill();
  ctx.strokeStyle = colors.bodyStroke;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Intake ducts (on sides of fuselage)
  ctx.fillStyle = colors.intake;
  ctx.beginPath();
  ctx.moveTo(-10 * ws, d * (h * 0.05));
  ctx.lineTo(-13 * ws, d * (-h * 0.02));
  ctx.lineTo(-12 * ws, d * (-h * 0.1));
  ctx.lineTo(-10 * ws, d * (-h * 0.05));
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(10 * ws, d * (h * 0.05));
  ctx.lineTo(13 * ws, d * (-h * 0.02));
  ctx.lineTo(12 * ws, d * (-h * 0.1));
  ctx.lineTo(10 * ws, d * (-h * 0.05));
  ctx.closePath();
  ctx.fill();

  // Center line detail
  ctx.beginPath();
  ctx.moveTo(0, noseY - d * 2 * s);
  ctx.lineTo(0, tailY + d * 4 * s);
  ctx.strokeStyle = colors.centerLine;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Vertical tail fin(s)
  const finBase = d * (-h * 0.35);
  const finTip = d * (-h * 0.18);
  if (opts && opts.twinFin) {
    // Twin angled vertical stabilizers
    ctx.beginPath();
    ctx.moveTo(-6 * ws, finBase);
    ctx.lineTo(-12 * ws, finTip);
    ctx.lineTo(-10 * ws, finBase + d * 5 * s);
    ctx.closePath();
    ctx.fillStyle = colors.finColor;
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(6 * ws, finBase);
    ctx.lineTo(12 * ws, finTip);
    ctx.lineTo(10 * ws, finBase + d * 5 * s);
    ctx.closePath();
    ctx.fillStyle = colors.finColor;
    ctx.fill();
  } else {
    // Single vertical tail fin
    ctx.beginPath();
    ctx.moveTo(0, finBase);
    ctx.lineTo(-3 * ws, finTip);
    ctx.lineTo(3 * ws, finTip);
    ctx.lineTo(2 * ws, finBase + d * 3 * s);
    ctx.lineTo(-2 * ws, finBase + d * 3 * s);
    ctx.closePath();
    ctx.fillStyle = colors.finColor;
    ctx.fill();
  }

  // Cockpit canopy
  const canopyFront = noseY - d * 4 * s;
  const canopyBack = d * (h * 0.12);
  ctx.beginPath();
  ctx.moveTo(0, canopyFront);
  ctx.lineTo(-5 * ws, canopyBack);
  ctx.quadraticCurveTo(0, canopyBack + d * 4 * s, 5 * ws, canopyBack);
  ctx.closePath();
  const cg = ctx.createLinearGradient(0, canopyFront, 0, canopyBack);
  cg.addColorStop(0, colors.canopyTop);
  cg.addColorStop(0.5, colors.canopyMid);
  cg.addColorStop(1, colors.canopyBottom);
  ctx.fillStyle = cg;
  ctx.fill();
  ctx.strokeStyle = colors.canopyEdge;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Canopy glare
  ctx.beginPath();
  ctx.moveTo(-1.5 * ws, canopyFront + d * 3 * s);
  ctx.lineTo(-2.5 * ws, (canopyFront + canopyBack) * 0.5);
  ctx.lineTo(-0.5 * ws, (canopyFront + canopyBack) * 0.5 + d * 2 * s);
  ctx.lineTo(0.5 * ws, canopyFront + d * 5 * s);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fill();

  // Nose tip
  ctx.beginPath();
  ctx.arc(0, noseY + d * 2 * s, 2 * s, 0, Math.PI * 2);
  ctx.fillStyle = colors.noseTip;
  ctx.fill();

  // Wing markings
  if (opts && opts.marking) {
    const markY = wingTip;
    const markXL = -wingSpan * 0.55;
    const markXR = wingSpan * 0.55;
    const mr = 4 * s;
    ctx.beginPath();
    ctx.arc(markXL, markY, mr, 0, Math.PI * 2);
    ctx.fillStyle = colors.markOuter;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(markXL, markY, mr * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = colors.markInner;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(markXR, markY, mr, 0, Math.PI * 2);
    ctx.fillStyle = colors.markOuter;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(markXR, markY, mr * 0.6, 0, Math.PI * 2);
    ctx.fillStyle = colors.markInner;
    ctx.fill();
  }

  // Missiles/pods under wings (optional)
  if (opts && opts.missiles) {
    const mY = d * (h * 0.15);
    const mLen = 8 * s;
    [-wingSpan * 0.45, wingSpan * 0.45].forEach(mx => {
      ctx.fillStyle = colors.missileColor || '#556';
      ctx.save();
      ctx.translate(mx, mY);
      ctx.beginPath();
      ctx.moveTo(0, d * mLen / 2);
      ctx.lineTo(-1.5 * s, d * (-mLen / 2));
      ctx.lineTo(1.5 * s, d * (-mLen / 2));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
}

// Color presets for each jet type
const PLAYER_LEVEL_COLORS = [
  null,
  { // LV1 - Í∏∞Î≥∏ Î∏îÎ£®/Ïã§Î≤Ñ
    flameCore: 'rgb(80,180,255', flameRGB: '50,120,255', flameCoreRGB: '200,230,255',
    nozzle: '#1a3050', wingTip: '#15406a', wingMid: '#2a6aaa', wingRoot: '#3580c0',
    wingEdge: 'rgba(100,180,255,0.4)', stabColor: '#1a4a7a',
    bodyEdge: '#1a4a80', bodyLight: '#b0c8e0', bodyCenter: '#d8e8f4',
    bodyStroke: 'rgba(100,170,230,0.5)', intake: '#2a5080',
    centerLine: 'rgba(40,120,220,0.5)', finColor: '#1a4a80',
    canopyTop: 'rgba(160,220,255,0.95)', canopyMid: 'rgba(80,180,255,0.8)',
    canopyBottom: 'rgba(40,120,200,0.6)', canopyEdge: 'rgba(180,230,255,0.7)',
    noseTip: 'rgba(100,200,255,0.7)', markOuter: 'rgba(255,255,255,0.5)',
    markInner: 'rgba(50,120,220,0.8)', missileColor: '#3a6a9a'
  },
  { // LV2 - ÏãúÏïà/Í∑∏Î¶∞ Í∞ïÌôî
    flameCore: 'rgb(50,255,200', flameRGB: '30,220,180', flameCoreRGB: '180,255,240',
    nozzle: '#103828', wingTip: '#0a4a3a', wingMid: '#1a8a6a', wingRoot: '#28aa80',
    wingEdge: 'rgba(60,230,180,0.45)', stabColor: '#105a45',
    bodyEdge: '#105a45', bodyLight: '#90d8c8', bodyCenter: '#c8f0e8',
    bodyStroke: 'rgba(60,210,170,0.5)', intake: '#186a50',
    centerLine: 'rgba(40,200,160,0.5)', finColor: '#105a45',
    canopyTop: 'rgba(140,255,220,0.95)', canopyMid: 'rgba(60,220,180,0.8)',
    canopyBottom: 'rgba(30,150,120,0.6)', canopyEdge: 'rgba(160,255,230,0.7)',
    noseTip: 'rgba(80,255,200,0.8)', markOuter: 'rgba(255,255,255,0.5)',
    markInner: 'rgba(40,180,140,0.8)', missileColor: '#2a7a6a'
  },
  { // LV3 - Í≥®Îìú/Ïï∞Î≤Ñ
    flameCore: 'rgb(255,200,50', flameRGB: '255,170,30', flameCoreRGB: '255,240,180',
    nozzle: '#3a2808', wingTip: '#5a3a08', wingMid: '#aa7a20', wingRoot: '#c89828',
    wingEdge: 'rgba(255,200,60,0.5)', stabColor: '#6a4a10',
    bodyEdge: '#6a4a10', bodyLight: '#e8c870', bodyCenter: '#f8e8a0',
    bodyStroke: 'rgba(255,200,80,0.55)', intake: '#7a5a18',
    centerLine: 'rgba(255,180,40,0.55)', finColor: '#6a4a10',
    canopyTop: 'rgba(255,240,150,0.95)', canopyMid: 'rgba(255,200,60,0.85)',
    canopyBottom: 'rgba(200,140,20,0.65)', canopyEdge: 'rgba(255,230,130,0.75)',
    noseTip: 'rgba(255,220,80,0.85)', markOuter: 'rgba(255,255,255,0.6)',
    markInner: 'rgba(220,170,30,0.85)', missileColor: '#8a6a20'
  },
  { // LV4 - Î†àÎìú/Ïò§Î†åÏßÄ ÌååÏù¥Ïñ¥
    flameCore: 'rgb(255,120,30', flameRGB: '255,80,10', flameCoreRGB: '255,220,160',
    nozzle: '#3a1008', wingTip: '#5a1808', wingMid: '#c04020', wingRoot: '#e05030',
    wingEdge: 'rgba(255,100,40,0.55)', stabColor: '#6a2010',
    bodyEdge: '#6a2010', bodyLight: '#e89070', bodyCenter: '#f8b8a0',
    bodyStroke: 'rgba(255,100,50,0.55)', intake: '#7a2818',
    centerLine: 'rgba(255,80,30,0.5)', finColor: '#6a2010',
    canopyTop: 'rgba(255,200,120,0.95)', canopyMid: 'rgba(255,120,40,0.85)',
    canopyBottom: 'rgba(200,60,10,0.65)', canopyEdge: 'rgba(255,180,100,0.75)',
    noseTip: 'rgba(255,100,30,0.9)', markOuter: 'rgba(255,255,255,0.6)',
    markInner: 'rgba(230,70,20,0.85)', missileColor: '#a04020'
  },
  { // LV5 MAX - ÌôîÏù¥Ìä∏/Í≥®Îìú Î†àÏ†ÑÎçîÎ¶¨
    flameCore: 'rgb(255,255,150', flameRGB: '255,230,100', flameCoreRGB: '255,255,230',
    nozzle: '#3a3020', wingTip: '#8a7030', wingMid: '#d0b050', wingRoot: '#e8d070',
    wingEdge: 'rgba(255,240,120,0.6)', stabColor: '#8a7530',
    bodyEdge: '#8a7530', bodyLight: '#f0e0b0', bodyCenter: '#fffff0',
    bodyStroke: 'rgba(255,240,150,0.6)', intake: '#9a8540',
    centerLine: 'rgba(255,230,100,0.6)', finColor: '#8a7530',
    canopyTop: 'rgba(255,255,200,0.98)', canopyMid: 'rgba(255,240,120,0.9)',
    canopyBottom: 'rgba(220,190,60,0.7)', canopyEdge: 'rgba(255,255,200,0.85)',
    noseTip: 'rgba(255,255,180,0.95)', markOuter: 'rgba(255,255,255,0.7)',
    markInner: 'rgba(240,210,60,0.9)', missileColor: '#b09040'
  }
];

const ENEMY_BASIC_COLORS = {
  flameCore: 'rgb(255,100,40',
  flameRGB: '255,70,20',
  flameCoreRGB: '255,200,120',
  nozzle: '#301010',
  wingTip: '#1a0808',
  wingMid: '#4a1818',
  wingRoot: '#5a2020',
  wingEdge: 'rgba(255,70,50,0.3)',
  stabColor: '#3a1010',
  bodyEdge: '#1a0808',
  bodyLight: '#5a2020',
  bodyCenter: '#6a2828',
  bodyStroke: 'rgba(255,60,40,0.35)',
  intake: '#3a1515',
  centerLine: 'rgba(255,60,40,0.3)',
  finColor: '#3a1010',
  canopyTop: 'rgba(255,200,100,0.9)',
  canopyMid: 'rgba(255,80,30,0.8)',
  canopyBottom: 'rgba(180,30,10,0.6)',
  canopyEdge: 'rgba(255,100,80,0.5)',
  noseTip: 'rgba(255,50,30,0.7)',
  markOuter: 'rgba(255,60,60,0.4)',
  markInner: 'rgba(200,30,30,0.7)',
  missileColor: '#5a2020'
};

const ENEMY_FAST_COLORS = {
  flameCore: 'rgb(255,170,40',
  flameRGB: '255,140,20',
  flameCoreRGB: '255,230,150',
  nozzle: '#302008',
  wingTip: '#1a0d00',
  wingMid: '#5a3010',
  wingRoot: '#6a3818',
  wingEdge: 'rgba(255,160,40,0.3)',
  stabColor: '#3a2008',
  bodyEdge: '#1a0d00',
  bodyLight: '#6a3818',
  bodyCenter: '#7a4420',
  bodyStroke: 'rgba(255,160,40,0.4)',
  intake: '#3a2510',
  centerLine: 'rgba(255,150,30,0.3)',
  finColor: '#3a2008',
  canopyTop: 'rgba(255,240,130,0.9)',
  canopyMid: 'rgba(255,170,40,0.8)',
  canopyBottom: 'rgba(200,100,10,0.6)',
  canopyEdge: 'rgba(255,180,80,0.5)',
  noseTip: 'rgba(255,180,40,0.7)',
  markOuter: 'rgba(255,160,40,0.4)',
  markInner: 'rgba(220,120,20,0.7)',
  missileColor: '#5a3818'
};

const ENEMY_TANK_COLORS = {
  flameCore: 'rgb(180,60,255',
  flameRGB: '160,40,255',
  flameCoreRGB: '230,180,255',
  nozzle: '#150820',
  wingTip: '#0a0515',
  wingMid: '#2a1540',
  wingRoot: '#3a1a55',
  wingEdge: 'rgba(160,60,220,0.3)',
  stabColor: '#1a0a2a',
  bodyEdge: '#0a0515',
  bodyLight: '#3a1a55',
  bodyCenter: '#4a2268',
  bodyStroke: 'rgba(180,80,255,0.4)',
  intake: '#1a0a2a',
  centerLine: 'rgba(150,60,220,0.3)',
  finColor: '#1a0a2a',
  canopyTop: 'rgba(230,170,255,0.9)',
  canopyMid: 'rgba(180,60,255,0.8)',
  canopyBottom: 'rgba(100,20,160,0.6)',
  canopyEdge: 'rgba(200,120,255,0.5)',
  noseTip: 'rgba(180,60,255,0.7)',
  markOuter: 'rgba(180,80,255,0.4)',
  markInner: 'rgba(120,30,200,0.7)',
  missileColor: '#2a1540'
};

const ENEMY_SHOOTER_COLORS = {
  flameCore: 'rgb(80,255,80',
  flameRGB: '60,220,60',
  flameCoreRGB: '180,255,180',
  nozzle: '#081508',
  wingTip: '#050d04',
  wingMid: '#1a3515',
  wingRoot: '#20401a',
  wingEdge: 'rgba(60,200,60,0.3)',
  stabColor: '#0a1a08',
  bodyEdge: '#050d04',
  bodyLight: '#1a3515',
  bodyCenter: '#20401a',
  bodyStroke: 'rgba(80,200,60,0.4)',
  intake: '#0a1a08',
  centerLine: 'rgba(60,180,60,0.3)',
  finColor: '#0a1a08',
  canopyTop: 'rgba(180,255,130,0.9)',
  canopyMid: 'rgba(80,220,60,0.8)',
  canopyBottom: 'rgba(30,120,20,0.6)',
  canopyEdge: 'rgba(120,230,100,0.5)',
  noseTip: 'rgba(80,220,60,0.7)',
  markOuter: 'rgba(80,220,60,0.4)',
  markInner: 'rgba(40,160,30,0.7)',
  missileColor: '#1a3515'
};

const ENEMY_BOSS_COLORS = {
  flameCore: 'rgb(255,60,20',
  flameRGB: '255,40,10',
  flameCoreRGB: '255,180,100',
  nozzle: '#2a0808',
  wingTip: '#1a0505',
  wingMid: '#5a1515',
  wingRoot: '#6a1a1a',
  wingEdge: 'rgba(255,50,50,0.4)',
  stabColor: '#3a0a0a',
  bodyEdge: '#1a0505',
  bodyLight: '#5a1818',
  bodyCenter: '#7a2222',
  bodyStroke: 'rgba(255,80,60,0.5)',
  intake: '#3a0a0a',
  centerLine: 'rgba(255,50,50,0.4)',
  finColor: '#3a0a0a',
  canopyTop: 'rgba(255,220,100,0.95)',
  canopyMid: 'rgba(255,80,20,0.85)',
  canopyBottom: 'rgba(200,20,10,0.7)',
  canopyEdge: 'rgba(255,120,80,0.6)',
  noseTip: 'rgba(255,50,20,0.8)',
  markOuter: 'rgba(255,50,50,0.5)',
  markInner: 'rgba(200,20,20,0.8)',
  missileColor: '#5a1515'
};

function drawPlayer() {
  const p = player;
  const lv = p.weaponLevel;
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.tilt * 0.05);

  // Jet grows slightly with each level
  const sizeScale = 1 + (lv - 1) * 0.07;
  const drawW = p.w * sizeScale;
  const drawH = p.h * sizeScale;

  p.engineFlicker += 0.3;
  const flicker = Math.sin(p.engineFlicker) * 0.3 + 0.7;

  const colors = PLAYER_LEVEL_COLORS[lv];

  // Aura glow for LV3+
  if (lv >= 3) {
    const glowR = drawW * 1.6 + 10;
    const auraAlpha = 0.06 + (lv - 3) * 0.04 + Math.sin(p.engineFlicker * 0.4) * 0.02;
    const auraGrad = ctx.createRadialGradient(0, 0, drawW * 0.3, 0, 0, glowR);
    auraGrad.addColorStop(0, colors.canopyMid.replace(/[\d.]+\)$/, auraAlpha * 2 + ')'));
    auraGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(0, 0, glowR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Energy ring for LV5
  if (lv >= 5) {
    const ringR = drawW * 1.3;
    ctx.beginPath();
    ctx.arc(0, 0, ringR, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,240,120,${0.15 + Math.sin(p.engineFlicker * 0.6) * 0.1})`;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Orbiting particles effect
    for (let i = 0; i < 3; i++) {
      const a = p.engineFlicker * 0.3 + i * Math.PI * 2 / 3;
      const ox = Math.cos(a) * ringR;
      const oy = Math.sin(a) * ringR;
      ctx.beginPath();
      ctx.arc(ox, oy, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,200,${0.5 + Math.sin(p.engineFlicker + i) * 0.3})`;
      ctx.fill();
    }
  }

  drawJet(0, 0, drawW, drawH, -1, colors, flicker, {
    twinFin: lv >= 2,
    marking: true,
    missiles: lv >= 2
  });

  // Level badge glow under the jet
  if (lv >= 3) {
    ctx.font = `bold ${9 + lv}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = colors.noseTip;
    ctx.globalAlpha = 0.6 + Math.sin(p.engineFlicker * 0.5) * 0.2;
    ctx.fillText('LV.' + (lv === 5 ? 'MAX' : lv), 0, drawH / 2 + 22 + (lv - 1) * 2);
    ctx.globalAlpha = 1;
  }

  // Shield when invincible
  if (p.invincible) {
    p.shieldPulse += 0.1;
    const shieldAlpha = 0.3 + Math.sin(p.shieldPulse) * 0.15;
    ctx.beginPath();
    const sr = drawW * 1.4 + 12;
    for (let i = 0; i < 6; i++) {
      const a = i * Math.PI / 3 - Math.PI / 2 + p.shieldPulse * 0.2;
      const sx = Math.cos(a) * sr;
      const sy = Math.sin(a) * sr;
      if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgba(80,200,255,${shieldAlpha + 0.3})`;
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.fillStyle = `rgba(80,200,255,${shieldAlpha * 0.15})`;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, sr * 0.7, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(150,230,255,${shieldAlpha * 0.4})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  ctx.restore();
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);
  const t = Date.now() * 0.005;
  const flicker = Math.sin(t * 3.5) * 0.3 + 0.7;

  let colors, opts;
  switch (e.type) {
    case 'basic':
      colors = ENEMY_BASIC_COLORS;
      opts = { twinFin: false, marking: true, missiles: false };
      break;
    case 'fast':
      colors = ENEMY_FAST_COLORS;
      opts = { twinFin: false, marking: false, missiles: false };
      break;
    case 'tank':
      colors = ENEMY_TANK_COLORS;
      opts = { twinFin: true, marking: true, missiles: true };
      break;
    case 'shooter':
      colors = ENEMY_SHOOTER_COLORS;
      opts = { twinFin: false, marking: true, missiles: true };
      break;
    case 'boss':
      colors = ENEMY_BOSS_COLORS;
      opts = { twinFin: true, marking: true, missiles: true };
      break;
    default:
      colors = ENEMY_BASIC_COLORS;
      opts = {};
  }

  drawJet(0, 0, e.w, e.h, 1, colors, flicker, opts);

  // HP bar for multi-hp enemies
  if (e.maxHp > 1) {
    const hpW = e.w * (e.type === 'boss' ? 2.5 : 1.2) + 10;
    const hpH = e.type === 'boss' ? 7 : 4;
    const hpY = -e.h / 2 - (e.type === 'boss' ? 20 : 12);
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-hpW / 2, hpY, hpW, hpH);
    ctx.strokeStyle = colors.wingEdge;
    ctx.lineWidth = 0.5;
    ctx.strokeRect(-hpW / 2, hpY, hpW, hpH);
    const hpRatio = e.hp / e.maxHp;
    const hpColor = hpRatio > 0.5 ? colors.canopyMid : hpRatio > 0.2 ? colors.canopyTop : colors.noseTip;
    ctx.fillStyle = hpColor;
    ctx.fillRect(-hpW / 2 + 1, hpY + 1, (hpW - 2) * hpRatio, hpH - 2);
    if (e.type === 'boss') {
      ctx.font = 'bold 9px monospace';
      ctx.textAlign = 'center';
      ctx.fillStyle = 'rgba(255,200,200,0.8)';
      ctx.fillText('BOSS', 0, hpY - 4);
    }
  }

  ctx.restore();
}

function drawBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);

  // Bigger bullets get a glow trail
  if (b.w >= 6) {
    const trailGrad = ctx.createRadialGradient(0, 0, b.w * 0.3, 0, 0, b.w * 2.5);
    trailGrad.addColorStop(0, b.color === '#fff' ? 'rgba(255,255,255,0.2)' : b.color.replace(')', ',0.15)').replace('rgb(', 'rgba(').replace('#', ''));
    trailGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = trailGrad;
    ctx.beginPath();
    ctx.arc(0, 0, b.w * 2.5, 0, Math.PI * 2);
    ctx.fill();
  }

  const grad = ctx.createLinearGradient(0, -b.h / 2, 0, b.h / 2);
  grad.addColorStop(0, '#fff');
  grad.addColorStop(0.4, b.color);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);

  ctx.shadowColor = b.color;
  ctx.shadowBlur = b.w >= 7 ? 14 : 8;
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillRect(-b.w / 4, -b.h / 2, b.w / 2, b.h / 3);
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawEnemyBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.beginPath();
  ctx.arc(0, 0, b.r || 4, 0, Math.PI * 2);
  ctx.fillStyle = '#ff5555';
  ctx.fill();
  ctx.shadowColor = '#ff3333';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.arc(0, 0, (b.r || 4) * 0.5, 0, Math.PI * 2);
  ctx.fillStyle = '#ffaaaa';
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawItem(item) {
  ctx.save();
  ctx.translate(item.x, item.y);
  item.pulse += 0.08;
  const scale = 1 + Math.sin(item.pulse) * 0.1;
  ctx.scale(scale, scale);

  let emoji, bgColor;
  switch (item.type) {
    case 'weapon': emoji = 'üî´'; bgColor = 'rgba(50,150,255,0.3)'; break;
    case 'bomb': emoji = 'üí£'; bgColor = 'rgba(255,100,50,0.3)'; break;
    case 'score': emoji = '‚≠ê'; bgColor = 'rgba(255,200,50,0.3)'; break;
    case 'heal': emoji = '‚ù§Ô∏è'; bgColor = 'rgba(255,50,80,0.3)'; break;
  }

  ctx.beginPath();
  ctx.arc(0, 0, 16, 0, Math.PI * 2);
  ctx.fillStyle = bgColor;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.font = '18px serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(emoji, 0, 0);

  ctx.restore();
}

function drawBackground(dt) {
  // Dark gradient sky
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#040810');
  skyGrad.addColorStop(0.5, '#0a1628');
  skyGrad.addColorStop(1, '#0c1a30');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  stars.forEach(s => {
    s.y += s.speed * (dt / 16);
    if (s.y > H + 10) { s.y = -10; s.x = Math.random() * W; }
    if (s.x > W) s.x -= W;
    ctx.beginPath();
    ctx.arc(s.x % W, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200,220,255,${s.brightness})`;
    ctx.fill();
  });

  // Clouds
  clouds.forEach(c => {
    c.y += c.speed * (dt / 16);
    if (c.y > H + 60) { c.y = -80; c.x = Math.random() * W; }
    ctx.fillStyle = `rgba(100,140,180,${c.alpha})`;
    ctx.beginPath();
    ctx.ellipse(c.x % W, c.y, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Collision detection
function rectCollide(a, b) {
  return Math.abs(a.x - b.x) < (a.w + b.w) / 2 &&
         Math.abs(a.y - b.y) < (a.h + b.h) / 2;
}

function circleCollide(a, b, ar, br) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy < (ar + br) * (ar + br);
}

// HUD
function updateHUD() {
  document.getElementById('hud-score').textContent = score.toLocaleString();

  const livesEl = document.getElementById('hud-lives');
  livesEl.innerHTML = '';
  for (let i = 0; i < player.lives; i++) {
    const s = document.createElement('span');
    s.textContent = '‚úàÔ∏è';
    livesEl.appendChild(s);
  }

  const bombsEl = document.getElementById('hud-bombs');
  bombsEl.innerHTML = '';
  for (let i = 0; i < player.bombs; i++) {
    const s = document.createElement('span');
    s.textContent = 'üí£';
    bombsEl.appendChild(s);
  }

  const w = WEAPONS[player.weaponLevel];
  document.getElementById('hud-weapon').textContent = w.name;
  document.getElementById('hud-weapon').style.color = w.color;
}

// Game update
function update(dt) {
  if (gameState !== STATE.PLAYING) return;
  gameTime += dt;
  difficulty = 1 + Math.floor(gameTime / 15000);

  // Player movement
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['KeyA'] || mobileDir.left) dx = -1;
  if (keys['ArrowRight'] || keys['KeyD'] || mobileDir.right) dx = 1;
  if (keys['ArrowUp'] || keys['KeyW'] || mobileDir.up) dy = -1;
  if (keys['ArrowDown'] || keys['KeyS'] || mobileDir.down) dy = 1;

  if (dx !== 0 && dy !== 0) {
    dx *= 0.707; dy *= 0.707;
  }

  player.x += dx * player.speed * (dt / 16);
  player.y += dy * player.speed * (dt / 16);
  player.x = Math.max(player.w, Math.min(W - player.w, player.x));
  player.y = Math.max(player.h, Math.min(H - player.h / 2, player.y));
  player.tilt += (dx * 3 - player.tilt) * 0.1;

  // Auto-fire
  player.fireTimer -= dt;
  const w = WEAPONS[player.weaponLevel];
  if (player.fireTimer <= 0) {
    fireBullets();
    player.fireTimer = w.fireRate;
  }

  // Invincibility timer
  if (player.invincible) {
    player.invincibleTimer -= dt;
    if (player.invincibleTimer <= 0) {
      player.invincible = false;
    }
  }

  // Update bullets
  bullets.forEach(b => { b.x += b.vx * (dt / 16); b.y += b.vy * (dt / 16); });
  bullets = bullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Update enemy bullets
  enemyBullets.forEach(b => { b.x += b.vx * (dt / 16); b.y += b.vy * (dt / 16); });
  enemyBullets = enemyBullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Spawn enemies
  spawnEnemies(dt);

  // Update enemies
  enemies.forEach(e => {
    e.moveTimer += dt * 0.003;
    switch (e.movePattern) {
      case 'straight':
        e.y += e.speed * (dt / 16);
        break;
      case 'zigzag':
        e.y += e.speed * (dt / 16);
        e.x += Math.sin(e.moveTimer) * 2.5;
        break;
      case 'boss':
        if (e.y < 80) {
          e.y += e.speed * (dt / 16);
        }
        e.x = W / 2 + Math.sin(e.moveTimer * 0.5) * (W / 3);
        break;
    }

    // Enemy shooting
    if (e.fireRate > 0) {
      e.fireTimer -= dt;
      if (e.fireTimer <= 0 && e.y > 0) {
        e.fireTimer = e.fireRate;
        if (e.type === 'boss') {
          // Boss fires spread
          for (let i = -2; i <= 2; i++) {
            const angle = Math.PI / 2 + i * 0.25;
            enemyBullets.push({
              x: e.x, y: e.y + e.h / 2,
              vx: Math.cos(angle) * 3.5,
              vy: Math.sin(angle) * 3.5,
              r: 5
            });
          }
        } else {
          const angle = Math.atan2(player.y - e.y, player.x - e.x);
          enemyBullets.push({
            x: e.x, y: e.y + e.h / 2,
            vx: Math.cos(angle) * 3,
            vy: Math.sin(angle) * 3,
            r: 4
          });
        }
      }
    }
  });
  enemies = enemies.filter(e => e.y < H + 100);

  // Bullet-enemy collision
  for (let i = bullets.length - 1; i >= 0; i--) {
    for (let j = enemies.length - 1; j >= 0; j--) {
      if (rectCollide(bullets[i], enemies[j])) {
        enemies[j].hp -= bullets[i].damage;
        // Hit particles
        for (let k = 0; k < 3; k++) {
          particles.push({
            x: bullets[i].x, y: bullets[i].y,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            life: 15, maxLife: 15,
            size: 2, color: bullets[i].color
          });
        }
        bullets.splice(i, 1);

        if (enemies[j].hp <= 0) {
          const e = enemies[j];
          createExplosion(e.x, e.y, e.w);
          score += e.score;
          kills++;
          if (Math.random() < 0.45) spawnItem(e.x, e.y);
          enemies.splice(j, 1);
          screenShake = Math.max(screenShake, 3);
          updateHUD();
        }
        break;
      }
    }
  }

  // Enemy bullet - player collision
  if (!player.invincible) {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      if (circleCollide(enemyBullets[i], player, enemyBullets[i].r, 14)) {
        enemyBullets.splice(i, 1);
        playerHit();
        break;
      }
    }
  }

  // Enemy-player collision
  if (!player.invincible) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      if (rectCollide(enemies[i], { x: player.x, y: player.y, w: player.w * 0.7, h: player.h * 0.7 })) {
        createExplosion(enemies[i].x, enemies[i].y, enemies[i].w);
        enemies.splice(i, 1);
        playerHit();
        break;
      }
    }
  }

  // Item pickup
  for (let i = items.length - 1; i >= 0; i--) {
    items[i].y += items[i].vy * (dt / 16);
    items[i].life -= dt / 16;
    if (items[i].life <= 0 || items[i].y > H + 30) {
      items.splice(i, 1);
      continue;
    }
    if (circleCollide(items[i], player, 16, 20)) {
      const item = items[i];
      switch (item.type) {
        case 'weapon':
          if (player.weaponLevel < 5) {
            player.weaponLevel++;
            const wc = PLAYER_LEVEL_COLORS[player.weaponLevel];
            showFloatingText(player.x, player.y - 50, WEAPONS[player.weaponLevel].name + '!', WEAPONS[player.weaponLevel].color);
            showFloatingText(player.x, player.y - 30, 'ÌôîÎ†• UP!', '#fff');
            // Upgrade flash particles
            for (let k = 0; k < 20; k++) {
              const ang = Math.random() * Math.PI * 2;
              const spd = Math.random() * 4 + 1.5;
              particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd,
                life: 30 + Math.random() * 20, maxLife: 50,
                size: Math.random() * 3 + 1.5,
                color: WEAPONS[player.weaponLevel].color
              });
            }
            screenShake = 4;
          } else {
            score += 500;
            showFloatingText(player.x, player.y - 40, '+500', '#ffd700');
          }
          break;
        case 'bomb':
          player.bombs = Math.min(player.bombs + 1, 8);
          showFloatingText(player.x, player.y - 40, 'Ìè≠ÌÉÑ +1!', '#ff6b35');
          break;
        case 'score':
          score += 300;
          showFloatingText(player.x, player.y - 40, '+300', '#ffd700');
          break;
        case 'heal':
          player.lives = Math.min(player.lives + 1, 5);
          showFloatingText(player.x, player.y - 40, 'ÏÉùÎ™Ö +1!', '#ff4466');
          break;
      }
      items.splice(i, 1);
      updateHUD();
    }
  }

  // Update particles
  particles.forEach(p => {
    p.x += p.vx * (dt / 16);
    p.y += p.vy * (dt / 16);
    p.life -= dt / 16;
    p.vx *= 0.98;
    p.vy *= 0.98;
  });
  particles = particles.filter(p => p.life > 0);

  // Update explosions
  explosions.forEach(ex => {
    ex.life -= ex.speed * (dt / 16);
    ex.radius += 2 * (dt / 16);
  });
  explosions = explosions.filter(ex => ex.life > 0);

  // Update screen effects
  if (screenShake > 0) screenShake *= 0.9;
  if (screenShake < 0.1) screenShake = 0;
  if (bombFlash > 0) bombFlash -= 0.03 * (dt / 16);
  if (damageFlash > 0) damageFlash -= 0.04 * (dt / 16);

  // Update floating texts
  floatingTexts.forEach(ft => {
    ft.y -= 1 * (dt / 16);
    ft.life -= dt / 16;
  });
  floatingTexts = floatingTexts.filter(ft => ft.life > 0);
}

function playerHit() {
  player.lives--;
  screenShake = 10;
  damageFlash = 1;
  createExplosion(player.x, player.y, 20);
  updateHUD();

  if (player.lives <= 0) {
    gameOver();
  } else {
    player.invincible = true;
    player.invincibleTimer = 2000;
    if (player.weaponLevel > 1) player.weaponLevel--;
  }
}

let floatingTexts = [];
function showFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 60 });
}

function gameOver() {
  gameState = STATE.GAMEOVER;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('skyFighterHigh', highScore.toString());
  }
  document.getElementById('final-score').textContent = score.toLocaleString();
  document.getElementById('final-stats').textContent =
    `Í≤©Ï∂î: ${kills}ÎåÄ | ÏÉùÏ°¥ÏãúÍ∞Ñ: ${Math.floor(gameTime / 1000)}Ï¥à | ÏµúÍ≥†Ï†êÏàò: ${highScore.toLocaleString()}`;
  document.getElementById('gameover-screen').classList.remove('hidden');
  document.getElementById('hud').classList.add('hidden');
}

function startGame() {
  gameState = STATE.PLAYING;
  score = 0; kills = 0; gameTime = 0; difficulty = 1; waveCount = 0;
  bullets = []; enemyBullets = []; enemies = []; particles = [];
  items = []; explosions = []; floatingTexts = [];
  screenShake = 0; bombFlash = 0; damageFlash = 0;
  enemySpawnTimer = 1000;

  initPlayer();

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  updateHUD();
}

// Draw loop
function draw() {
  ctx.save();

  // Screen shake
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake * 2,
      (Math.random() - 0.5) * screenShake * 2
    );
  }

  drawBackground(16);

  if (gameState === STATE.PLAYING || gameState === STATE.GAMEOVER) {
    // Draw items
    items.forEach(item => drawItem(item));

    // Draw bullets
    bullets.forEach(b => drawBullet(b));

    // Draw enemy bullets
    enemyBullets.forEach(b => drawEnemyBullet(b));

    // Draw enemies
    enemies.forEach(e => drawEnemy(e));

    // Draw player
    if (gameState === STATE.PLAYING) {
      if (player.invincible && player.invincibleTimer < 1000) {
        if (Math.floor(Date.now() / 80) % 2 === 0) drawPlayer();
      } else {
        drawPlayer();
      }
    }

    // Draw explosions
    explosions.forEach(ex => {
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,200,50,${ex.life * 0.4})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius * 0.6, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,200,${ex.life * 0.6})`;
      ctx.fill();
    });

    // Draw particles
    particles.forEach(p => {
      const alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    // Draw floating texts
    floatingTexts.forEach(ft => {
      const alpha = ft.life / 60;
      ctx.font = 'bold 16px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = ft.color;
      ctx.globalAlpha = alpha;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.globalAlpha = 1;
    });

    // Bomb flash
    if (bombFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${bombFlash * 0.5})`;
      ctx.fillRect(-50, -50, W + 100, H + 100);
    }

    // Damage flash
    if (damageFlash > 0) {
      ctx.fillStyle = `rgba(255,0,0,${damageFlash * 0.3})`;
      ctx.fillRect(-50, -50, W + 100, H + 100);
    }
  }

  ctx.restore();
}

// Game loop
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = Math.min(timestamp - lastTime, 33);
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

// Event listeners
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', startGame);

// Keyboard start
window.addEventListener('keydown', e => {
  if (e.code === 'Enter' || e.code === 'Space') {
    if (gameState === STATE.MENU) startGame();
    else if (gameState === STATE.GAMEOVER) startGame();
  }
});

// Initialize
initPlayer();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
