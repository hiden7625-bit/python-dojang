<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Sky Fighter - Ïä§Ïπ¥Ïù¥ ÌååÏù¥ÌÑ∞</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: hidden;
  font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
  user-select: none;
}
#gameCanvas {
  display: block;
  image-rendering: pixelated;
}
#ui-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#start-screen, #gameover-screen {
  pointer-events: auto;
  text-align: center;
  color: #fff;
  padding: 40px;
  border-radius: 20px;
  background: rgba(0,0,0,0.85);
  border: 2px solid rgba(100,180,255,0.3);
  backdrop-filter: blur(10px);
  max-width: 420px;
}
#start-screen h1 {
  font-size: 42px;
  font-weight: 800;
  background: linear-gradient(135deg, #00d2ff, #3a7bd5, #ff6b6b);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 10px;
  letter-spacing: -1px;
}
#start-screen .subtitle {
  font-size: 14px;
  color: #8ab4f8;
  margin-bottom: 30px;
}
#gameover-screen h2 {
  font-size: 36px;
  color: #ff6b6b;
  margin-bottom: 10px;
}
#gameover-screen .final-score {
  font-size: 48px;
  font-weight: 800;
  color: #ffd700;
  margin: 15px 0;
}
.btn {
  display: inline-block;
  padding: 14px 48px;
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  background: linear-gradient(135deg, #3a7bd5, #00d2ff);
  border: none;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.3s;
  letter-spacing: 1px;
  margin-top: 15px;
}
.btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0,210,255,0.4); }
.controls-info {
  margin-top: 25px;
  font-size: 12px;
  color: #7a8ba8;
  line-height: 1.8;
}
.controls-info kbd {
  display: inline-block;
  padding: 2px 8px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  font-family: monospace;
  font-size: 11px;
  color: #aac;
}
#hud {
  position: absolute;
  top: 0; left: 0; right: 0;
  padding: 10px 16px;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  pointer-events: none;
  z-index: 10;
}
#hud-left, #hud-right { display: flex; flex-direction: column; gap: 4px; }
#hud-left { align-items: flex-start; }
#hud-right { align-items: flex-end; }
.hud-label {
  font-size: 11px;
  color: #5a7a9a;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.hud-value {
  font-size: 22px;
  font-weight: 800;
  color: #fff;
  text-shadow: 0 0 10px rgba(0,200,255,0.5);
}
.hud-value.score { color: #ffd700; }
.hud-lives { display: flex; gap: 4px; margin-top: 2px; }
.hud-lives span { font-size: 18px; }
.hud-bombs { display: flex; gap: 3px; margin-top: 2px; }
.hud-bombs span { font-size: 16px; }
.hud-weapon {
  font-size: 13px;
  font-weight: 600;
  color: #4af;
  margin-top: 2px;
}
#mobile-controls {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  padding: 20px;
  display: none;
  justify-content: space-between;
  align-items: flex-end;
  pointer-events: auto;
  z-index: 20;
}
.mobile-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: rgba(255,255,255,0.12);
  border: 2px solid rgba(255,255,255,0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  color: rgba(255,255,255,0.7);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.mobile-btn:active { background: rgba(255,255,255,0.3); }
.mobile-btn.bomb-btn {
  background: rgba(255,80,80,0.2);
  border-color: rgba(255,80,80,0.4);
  font-size: 22px;
}
.dpad {
  display: grid;
  grid-template-columns: 56px 56px 56px;
  grid-template-rows: 56px 56px 56px;
  gap: 4px;
}
.dpad .mobile-btn { width: 56px; height: 56px; font-size: 22px; }
.dpad-up { grid-column: 2; grid-row: 1; }
.dpad-down { grid-column: 2; grid-row: 3; }
.dpad-left { grid-column: 1; grid-row: 2; }
.dpad-right { grid-column: 3; grid-row: 2; }
.hidden { display: none !important; }
@media (pointer: coarse) {
  #mobile-controls { display: flex; }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="hud" class="hidden">
  <div id="hud-left">
    <span class="hud-label">Score</span>
    <span class="hud-value score" id="hud-score">0</span>
    <span class="hud-label" style="margin-top:6px">Lives</span>
    <div class="hud-lives" id="hud-lives"></div>
  </div>
  <div id="hud-right">
    <span class="hud-label">Weapon</span>
    <span class="hud-weapon" id="hud-weapon">LV.1 Í∏∞Î≥∏ Í∏∞Í¥ÄÌè¨</span>
    <span class="hud-label" style="margin-top:6px">Î¨¥Ï†Å Ìè≠ÌÉÑ</span>
    <div class="hud-bombs" id="hud-bombs"></div>
  </div>
</div>

<div id="ui-overlay">
  <div id="start-screen">
    <h1>SKY FIGHTER</h1>
    <div class="subtitle">Ïä§Ïπ¥Ïù¥ ÌååÏù¥ÌÑ∞ - ÌïòÎäòÏùò Ï†ÑÏÇ¨</div>
    <button class="btn" id="btn-start">Í≤åÏûÑ ÏãúÏûë</button>
    <div class="controls-info">
      <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> <kbd>‚Üë</kbd> <kbd>‚Üì</kbd> Ïù¥Îèô &nbsp;|&nbsp;
      <kbd>Space</kbd> ÏÇ¨Í≤© (ÏûêÎèô)<br>
      <kbd>B</kbd> Î¨¥Ï†Å Ìè≠ÌÉÑ &nbsp;|&nbsp; Î™®Î∞îÏùº: ÌÑ∞Ïπò Î≤ÑÌäº
    </div>
  </div>
  <div id="gameover-screen" class="hidden">
    <h2>GAME OVER</h2>
    <div>ÏµúÏ¢Ö Ï†êÏàò</div>
    <div class="final-score" id="final-score">0</div>
    <div id="final-stats" style="font-size:13px;color:#8ab4f8;margin-bottom:10px;"></div>
    <button class="btn" id="btn-restart">Îã§Ïãú ÏãúÏûë</button>
  </div>
</div>

<div id="mobile-controls">
  <div class="dpad">
    <div class="mobile-btn dpad-up" data-dir="up">‚ñ≤</div>
    <div class="mobile-btn dpad-left" data-dir="left">‚óÄ</div>
    <div class="mobile-btn dpad-right" data-dir="right">‚ñ∂</div>
    <div class="mobile-btn dpad-down" data-dir="down">‚ñº</div>
  </div>
  <div style="display:flex;gap:12px;align-items:flex-end;">
    <div class="mobile-btn bomb-btn" id="mobile-bomb">üí£</div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let W, H;
function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}
resize();
window.addEventListener('resize', resize);

// Game state
const STATE = { MENU: 0, PLAYING: 1, GAMEOVER: 2 };
let gameState = STATE.MENU;
let score = 0;
let highScore = parseInt(localStorage.getItem('skyFighterHigh') || '0');
let kills = 0;
let gameTime = 0;
let difficulty = 1;

// Input
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Mobile input
const mobileDir = { up: false, down: false, left: false, right: false };
document.querySelectorAll('.dpad .mobile-btn').forEach(btn => {
  const dir = btn.dataset.dir;
  const start = () => { mobileDir[dir] = true; };
  const end = () => { mobileDir[dir] = false; };
  btn.addEventListener('touchstart', e => { e.preventDefault(); start(); });
  btn.addEventListener('touchend', e => { e.preventDefault(); end(); });
  btn.addEventListener('touchcancel', e => { end(); });
});
document.getElementById('mobile-bomb').addEventListener('touchstart', e => { e.preventDefault(); useBomb(); });

// Stars background
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    size: Math.random() * 2 + 0.5,
    speed: Math.random() * 2 + 0.5,
    brightness: Math.random() * 0.5 + 0.5
  });
}

// Clouds
const clouds = [];
for (let i = 0; i < 8; i++) {
  clouds.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    w: Math.random() * 200 + 100,
    h: Math.random() * 40 + 20,
    speed: Math.random() * 0.5 + 0.3,
    alpha: Math.random() * 0.04 + 0.02
  });
}

// Player
let player;
function initPlayer() {
  player = {
    x: W / 2,
    y: H - 120,
    w: 40,
    h: 48,
    speed: 5,
    lives: 3,
    weaponLevel: 1,
    bombs: 5,
    invincible: false,
    invincibleTimer: 0,
    fireRate: 150,
    fireTimer: 0,
    engineFlicker: 0,
    tilt: 0,
    shieldPulse: 0
  };
}

// Bullets
let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let items = [];
let explosions = [];
let screenShake = 0;
let bombFlash = 0;
let damageFlash = 0;

// Enemy spawn timer
let enemySpawnTimer = 0;
let enemySpawnRate = 1200;
let waveCount = 0;

// Weapon definitions
const WEAPONS = {
  1: { name: 'LV.1 Í∏∞Î≥∏ Í∏∞Í¥ÄÌè¨', fireRate: 180, color: '#4af', damage: 1 },
  2: { name: 'LV.2 ÎçîÎ∏î Í∏∞Í¥ÄÌè¨', fireRate: 160, color: '#4f8', damage: 1 },
  3: { name: 'LV.3 Ìä∏Î¶¨Ìîå Ï∫êÎÖº', fireRate: 140, color: '#fa4', damage: 1.5 },
  4: { name: 'LV.4 Ïä§ÌîÑÎ†àÎìú Ï∫êÎÖº', fireRate: 120, color: '#f4a', damage: 2 },
  5: { name: 'LV.MAX Î©îÍ∞Ä Ï∫êÎÖº', fireRate: 100, color: '#f44', damage: 3 }
};

function fireBullets() {
  const w = WEAPONS[player.weaponLevel];
  const cx = player.x;
  const cy = player.y - player.h / 2;
  const bSpeed = 10;

  switch (player.weaponLevel) {
    case 1:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      break;
    case 2:
      bullets.push({ x: cx - 10, y: cy, vx: 0, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 10, y: cy, vx: 0, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      break;
    case 3:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 5, h: 16, color: w.color, damage: w.damage });
      bullets.push({ x: cx - 14, y: cy + 6, vx: -1.5, vy: -bSpeed, w: 4, h: 12, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 14, y: cy + 6, vx: 1.5, vy: -bSpeed, w: 4, h: 12, color: w.color, damage: w.damage });
      break;
    case 4:
      bullets.push({ x: cx, y: cy, vx: 0, vy: -bSpeed, w: 6, h: 18, color: w.color, damage: w.damage });
      bullets.push({ x: cx - 12, y: cy + 4, vx: -1.2, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 12, y: cy + 4, vx: 1.2, vy: -bSpeed, w: 4, h: 14, color: w.color, damage: w.damage });
      bullets.push({ x: cx - 22, y: cy + 10, vx: -2.8, vy: -bSpeed * 0.9, w: 3, h: 10, color: w.color, damage: w.damage });
      bullets.push({ x: cx + 22, y: cy + 10, vx: 2.8, vy: -bSpeed * 0.9, w: 3, h: 10, color: w.color, damage: w.damage });
      break;
    case 5:
      for (let i = -3; i <= 3; i++) {
        const angle = i * 0.12;
        bullets.push({
          x: cx + i * 8, y: cy + Math.abs(i) * 4,
          vx: Math.sin(angle) * bSpeed * 0.4,
          vy: -bSpeed + Math.abs(i) * 0.3,
          w: i === 0 ? 7 : 4, h: i === 0 ? 20 : 14,
          color: i === 0 ? '#fff' : w.color,
          damage: i === 0 ? w.damage * 1.5 : w.damage
        });
      }
      break;
  }
}

// Enemy types
function createEnemy(type) {
  const e = {
    x: Math.random() * (W - 80) + 40,
    y: -60,
    type: type || 'basic',
    hp: 1,
    maxHp: 1,
    speed: 2,
    w: 36,
    h: 36,
    score: 100,
    fireTimer: 0,
    fireRate: 0,
    movePattern: 'straight',
    moveTimer: Math.random() * Math.PI * 2,
    color: '#f55'
  };

  switch (e.type) {
    case 'basic':
      e.hp = 1; e.maxHp = 1; e.speed = 1.5 + difficulty * 0.3;
      e.score = 100; e.color = '#e74c3c'; e.w = 32; e.h = 32;
      break;
    case 'fast':
      e.hp = 1; e.maxHp = 1; e.speed = 3 + difficulty * 0.4;
      e.score = 150; e.color = '#e67e22'; e.w = 28; e.h = 28;
      e.movePattern = 'zigzag';
      break;
    case 'tank':
      e.hp = 3 + Math.floor(difficulty * 0.5); e.maxHp = e.hp;
      e.speed = 1 + difficulty * 0.15; e.score = 300;
      e.color = '#8e44ad'; e.w = 44; e.h = 44;
      break;
    case 'shooter':
      e.hp = 2; e.maxHp = 2; e.speed = 1.2 + difficulty * 0.2;
      e.score = 250; e.color = '#2ecc71'; e.w = 36; e.h = 36;
      e.fireRate = 1500 - difficulty * 50;
      e.fireTimer = Math.random() * 500;
      break;
    case 'boss':
      e.hp = 15 + difficulty * 5; e.maxHp = e.hp;
      e.speed = 0.6; e.score = 2000;
      e.color = '#c0392b'; e.w = 70; e.h = 60;
      e.fireRate = 800; e.fireTimer = 0;
      e.movePattern = 'boss';
      e.x = W / 2;
      break;
  }
  return e;
}

function spawnEnemies(dt) {
  enemySpawnTimer -= dt;
  if (enemySpawnTimer <= 0) {
    waveCount++;
    const roll = Math.random();
    if (waveCount % 25 === 0) {
      enemies.push(createEnemy('boss'));
    } else if (roll < 0.4) {
      enemies.push(createEnemy('basic'));
      if (difficulty > 2) enemies.push(createEnemy('basic'));
    } else if (roll < 0.6) {
      enemies.push(createEnemy('fast'));
    } else if (roll < 0.8) {
      enemies.push(createEnemy('tank'));
    } else {
      enemies.push(createEnemy('shooter'));
    }
    enemySpawnRate = Math.max(300, 1200 - difficulty * 80);
    enemySpawnTimer = enemySpawnRate + Math.random() * 400;
  }
}

// Items
function spawnItem(x, y) {
  const roll = Math.random();
  let type;
  if (roll < 0.4) type = 'weapon';
  else if (roll < 0.65) type = 'bomb';
  else if (roll < 0.85) type = 'score';
  else type = 'heal';

  items.push({
    x, y,
    type,
    vy: 1.5,
    w: 24, h: 24,
    pulse: 0,
    life: 600
  });
}

function useBomb() {
  if (gameState !== STATE.PLAYING || player.bombs <= 0) return;
  player.bombs--;
  player.invincible = true;
  player.invincibleTimer = 3000;
  bombFlash = 1;
  screenShake = 15;

  enemies.forEach(e => {
    createExplosion(e.x, e.y, e.w);
    score += e.score;
    kills++;
  });
  enemies = [];
  enemyBullets = [];

  for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 8 + 2;
    particles.push({
      x: player.x, y: player.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 60 + Math.random() * 40,
      maxLife: 100,
      size: Math.random() * 4 + 2,
      color: `hsl(${Math.random() * 60 + 30}, 100%, ${Math.random() * 30 + 60}%)`
    });
  }
  updateHUD();
}

window.addEventListener('keydown', e => {
  if (e.code === 'KeyB') useBomb();
});

function createExplosion(x, y, size) {
  explosions.push({ x, y, radius: 0, maxRadius: size * 1.5 + 20, life: 1, speed: 0.04 });
  for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 5 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 30,
      maxLife: 60,
      size: Math.random() * 3 + 1,
      color: `hsl(${Math.random() * 40 + 10}, 100%, ${Math.random() * 30 + 50}%)`
    });
  }
}

// Draw functions
function drawPlayer() {
  const p = player;
  ctx.save();
  ctx.translate(p.x, p.y);
  ctx.rotate(p.tilt * 0.05);

  p.engineFlicker += 0.3;
  const flicker = Math.sin(p.engineFlicker) * 0.3 + 0.7;

  // Twin engine glow
  const engGrad1 = ctx.createRadialGradient(-8, p.h / 2 + 4, 1, -8, p.h / 2 + 12, 10);
  engGrad1.addColorStop(0, `rgba(80,180,255,${flicker})`);
  engGrad1.addColorStop(0.5, `rgba(30,100,255,${flicker * 0.4})`);
  engGrad1.addColorStop(1, 'rgba(0,50,200,0)');
  ctx.fillStyle = engGrad1;
  ctx.fillRect(-16, p.h / 2, 16, 16);
  const engGrad2 = ctx.createRadialGradient(8, p.h / 2 + 4, 1, 8, p.h / 2 + 12, 10);
  engGrad2.addColorStop(0, `rgba(80,180,255,${flicker})`);
  engGrad2.addColorStop(0.5, `rgba(30,100,255,${flicker * 0.4})`);
  engGrad2.addColorStop(1, 'rgba(0,50,200,0)');
  ctx.fillStyle = engGrad2;
  ctx.fillRect(0, p.h / 2, 16, 16);

  // Twin engine flames
  const flameH = 14 + Math.sin(p.engineFlicker * 2.5) * 7;
  ctx.beginPath();
  ctx.moveTo(-12, p.h / 2);
  ctx.lineTo(-8, p.h / 2 + flameH);
  ctx.lineTo(-4, p.h / 2);
  ctx.fillStyle = `rgba(120,200,255,${flicker * 0.9})`;
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(4, p.h / 2);
  ctx.lineTo(8, p.h / 2 + flameH);
  ctx.lineTo(12, p.h / 2);
  ctx.fillStyle = `rgba(120,200,255,${flicker * 0.9})`;
  ctx.fill();
  // Inner flame white core
  const flameH2 = flameH * 0.6;
  ctx.beginPath();
  ctx.moveTo(-10, p.h / 2);
  ctx.lineTo(-8, p.h / 2 + flameH2);
  ctx.lineTo(-6, p.h / 2);
  ctx.fillStyle = `rgba(220,240,255,${flicker * 0.7})`;
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(6, p.h / 2);
  ctx.lineTo(8, p.h / 2 + flameH2);
  ctx.lineTo(10, p.h / 2);
  ctx.fillStyle = `rgba(220,240,255,${flicker * 0.7})`;
  ctx.fill();

  // Main wings (large, swept-back delta wings)
  ctx.beginPath();
  ctx.moveTo(-6, p.h * 0.1);
  ctx.lineTo(-p.w * 1.3, p.h * 0.42);
  ctx.lineTo(-p.w * 1.2, p.h * 0.48);
  ctx.lineTo(-8, p.h * 0.35);
  ctx.closePath();
  const wingGradL = ctx.createLinearGradient(-p.w * 1.3, 0, 0, 0);
  wingGradL.addColorStop(0, '#1a4a80');
  wingGradL.addColorStop(0.5, '#2a6ab0');
  wingGradL.addColorStop(1, '#3a80c8');
  ctx.fillStyle = wingGradL;
  ctx.fill();
  ctx.strokeStyle = 'rgba(100,180,255,0.4)';
  ctx.lineWidth = 1;
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(6, p.h * 0.1);
  ctx.lineTo(p.w * 1.3, p.h * 0.42);
  ctx.lineTo(p.w * 1.2, p.h * 0.48);
  ctx.lineTo(8, p.h * 0.35);
  ctx.closePath();
  const wingGradR = ctx.createLinearGradient(0, 0, p.w * 1.3, 0);
  wingGradR.addColorStop(0, '#3a80c8');
  wingGradR.addColorStop(0.5, '#2a6ab0');
  wingGradR.addColorStop(1, '#1a4a80');
  ctx.fillStyle = wingGradR;
  ctx.fill();
  ctx.strokeStyle = 'rgba(100,180,255,0.4)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Wing roundels (blue circles - ally marking)
  ctx.beginPath();
  ctx.arc(-p.w * 0.7, p.h * 0.35, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-p.w * 0.7, p.h * 0.35, 2.5, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(50,120,220,0.9)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(p.w * 0.7, p.h * 0.35, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(p.w * 0.7, p.h * 0.35, 2.5, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(50,120,220,0.9)';
  ctx.fill();

  // Fuselage (sleek F-22 style body)
  ctx.beginPath();
  ctx.moveTo(0, -p.h / 2 - 4);
  ctx.lineTo(-5, -p.h / 2 + 6);
  ctx.lineTo(-10, p.h * 0.05);
  ctx.lineTo(-12, p.h * 0.3);
  ctx.lineTo(-10, p.h / 2);
  ctx.lineTo(10, p.h / 2);
  ctx.lineTo(12, p.h * 0.3);
  ctx.lineTo(10, p.h * 0.05);
  ctx.lineTo(5, -p.h / 2 + 6);
  ctx.closePath();

  const bodyGrad = ctx.createLinearGradient(-12, 0, 12, 0);
  bodyGrad.addColorStop(0, '#2a5a90');
  bodyGrad.addColorStop(0.3, '#d0dde8');
  bodyGrad.addColorStop(0.5, '#e8f0f8');
  bodyGrad.addColorStop(0.7, '#d0dde8');
  bodyGrad.addColorStop(1, '#2a5a90');
  ctx.fillStyle = bodyGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(100,160,220,0.5)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Center stripe (blue accent line)
  ctx.beginPath();
  ctx.moveTo(0, -p.h / 2 + 2);
  ctx.lineTo(0, p.h / 2 - 4);
  ctx.strokeStyle = 'rgba(40,120,220,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Tail fins
  ctx.beginPath();
  ctx.moveTo(-8, p.h * 0.25);
  ctx.lineTo(-16, p.h * 0.15);
  ctx.lineTo(-14, p.h * 0.35);
  ctx.lineTo(-10, p.h * 0.35);
  ctx.closePath();
  ctx.fillStyle = '#1a4a80';
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(8, p.h * 0.25);
  ctx.lineTo(16, p.h * 0.15);
  ctx.lineTo(14, p.h * 0.35);
  ctx.lineTo(10, p.h * 0.35);
  ctx.closePath();
  ctx.fillStyle = '#1a4a80';
  ctx.fill();

  // Cockpit canopy (bright blue glass)
  ctx.beginPath();
  ctx.moveTo(0, -p.h / 2 + 4);
  ctx.lineTo(-5, -p.h / 6);
  ctx.quadraticCurveTo(0, -p.h / 6 + 4, 5, -p.h / 6);
  ctx.closePath();
  const cockpitGrad = ctx.createLinearGradient(0, -p.h / 2, 0, -p.h / 6);
  cockpitGrad.addColorStop(0, 'rgba(160,220,255,0.95)');
  cockpitGrad.addColorStop(0.5, 'rgba(80,180,255,0.8)');
  cockpitGrad.addColorStop(1, 'rgba(40,120,200,0.6)');
  ctx.fillStyle = cockpitGrad;
  ctx.fill();
  ctx.strokeStyle = 'rgba(180,230,255,0.7)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Cockpit glare highlight
  ctx.beginPath();
  ctx.moveTo(-2, -p.h / 2 + 7);
  ctx.lineTo(-3, -p.h / 4);
  ctx.lineTo(-1, -p.h / 4 + 2);
  ctx.lineTo(0, -p.h / 2 + 9);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fill();

  // Nose tip light
  ctx.beginPath();
  ctx.arc(0, -p.h / 2 - 2, 2, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(100,200,255,${0.5 + Math.sin(p.engineFlicker * 0.5) * 0.3})`;
  ctx.fill();

  // Shield when invincible
  if (p.invincible) {
    p.shieldPulse += 0.1;
    const shieldAlpha = 0.3 + Math.sin(p.shieldPulse) * 0.15;
    // Hexagonal shield effect
    ctx.beginPath();
    const sr = p.w * 1.4 + 10;
    for (let i = 0; i < 6; i++) {
      const a = i * Math.PI / 3 - Math.PI / 2 + p.shieldPulse * 0.2;
      const sx = Math.cos(a) * sr;
      const sy = Math.sin(a) * sr;
      if (i === 0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgba(80,200,255,${shieldAlpha + 0.3})`;
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.fillStyle = `rgba(80,200,255,${shieldAlpha * 0.15})`;
    ctx.fill();
    // Inner ring
    ctx.beginPath();
    ctx.arc(0, 0, sr * 0.7, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(150,230,255,${shieldAlpha * 0.4})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  ctx.restore();
}

function drawEnemy(e) {
  ctx.save();
  ctx.translate(e.x, e.y);
  const t = Date.now() * 0.005;

  if (e.type === 'boss') {
    // Boss - heavy bomber style, facing down (toward player)
    // Dark menacing engine glow on top (engines face up)
    const bFlicker = Math.sin(t * 3) * 0.3 + 0.7;
    ctx.beginPath();
    ctx.arc(-20, -e.h / 2 - 3, 6, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,50,20,${bFlicker * 0.7})`;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(20, -e.h / 2 - 3, 6, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,50,20,${bFlicker * 0.7})`;
    ctx.fill();
    // Engine flame trails (going up = behind boss)
    const bFlameH = 10 + Math.sin(t * 6) * 5;
    ctx.beginPath();
    ctx.moveTo(-24, -e.h / 2);
    ctx.lineTo(-20, -e.h / 2 - bFlameH);
    ctx.lineTo(-16, -e.h / 2);
    ctx.fillStyle = `rgba(255,80,30,${bFlicker * 0.6})`;
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(16, -e.h / 2);
    ctx.lineTo(20, -e.h / 2 - bFlameH);
    ctx.lineTo(24, -e.h / 2);
    ctx.fillStyle = `rgba(255,80,30,${bFlicker * 0.6})`;
    ctx.fill();

    // Boss massive swept wings
    ctx.beginPath();
    ctx.moveTo(-14, -e.h * 0.15);
    ctx.lineTo(-e.w * 1.1, e.h * 0.1);
    ctx.lineTo(-e.w * 1.05, e.h * 0.2);
    ctx.lineTo(-e.w * 0.6, e.h * 0.15);
    ctx.lineTo(-14, e.h * 0.05);
    ctx.closePath();
    const bwGL = ctx.createLinearGradient(-e.w * 1.1, 0, 0, 0);
    bwGL.addColorStop(0, '#1a0a0a');
    bwGL.addColorStop(0.5, '#4a1515');
    bwGL.addColorStop(1, '#3a1010');
    ctx.fillStyle = bwGL;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,60,60,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(14, -e.h * 0.15);
    ctx.lineTo(e.w * 1.1, e.h * 0.1);
    ctx.lineTo(e.w * 1.05, e.h * 0.2);
    ctx.lineTo(e.w * 0.6, e.h * 0.15);
    ctx.lineTo(14, e.h * 0.05);
    ctx.closePath();
    const bwGR = ctx.createLinearGradient(0, 0, e.w * 1.1, 0);
    bwGR.addColorStop(0, '#3a1010');
    bwGR.addColorStop(0.5, '#4a1515');
    bwGR.addColorStop(1, '#1a0a0a');
    ctx.fillStyle = bwGR;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,60,60,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Boss body (pointing downward toward player)
    ctx.beginPath();
    ctx.moveTo(0, e.h / 2 + 6);
    ctx.lineTo(-8, e.h * 0.3);
    ctx.lineTo(-16, -e.h * 0.1);
    ctx.lineTo(-14, -e.h / 2);
    ctx.lineTo(14, -e.h / 2);
    ctx.lineTo(16, -e.h * 0.1);
    ctx.lineTo(8, e.h * 0.3);
    ctx.closePath();
    const bossGrad = ctx.createLinearGradient(-16, 0, 16, 0);
    bossGrad.addColorStop(0, '#1a0808');
    bossGrad.addColorStop(0.3, '#5a1818');
    bossGrad.addColorStop(0.5, '#6a2020');
    bossGrad.addColorStop(0.7, '#5a1818');
    bossGrad.addColorStop(1, '#1a0808');
    ctx.fillStyle = bossGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,80,80,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Boss red cockpit (menacing eye)
    ctx.beginPath();
    ctx.ellipse(0, e.h * 0.2, 7, 5, 0, 0, Math.PI * 2);
    const eyeGrad = ctx.createRadialGradient(0, e.h * 0.2, 1, 0, e.h * 0.2, 7);
    eyeGrad.addColorStop(0, `rgba(255,255,100,${0.8 + Math.sin(t * 2) * 0.2})`);
    eyeGrad.addColorStop(0.5, 'rgba(255,50,20,0.9)');
    eyeGrad.addColorStop(1, 'rgba(150,0,0,0.6)');
    ctx.fillStyle = eyeGrad;
    ctx.fill();
    // Glowing red eye effect
    ctx.shadowColor = '#ff3300';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(0, e.h * 0.2, 3, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,200,50,0.9)';
    ctx.fill();
    ctx.shadowBlur = 0;

    // Boss danger markings on wings
    ctx.strokeStyle = 'rgba(255,40,40,0.5)';
    ctx.lineWidth = 2;
    // Left wing X mark
    ctx.beginPath();
    ctx.moveTo(-e.w * 0.65, e.h * 0.08);
    ctx.lineTo(-e.w * 0.5, e.h * 0.18);
    ctx.moveTo(-e.w * 0.5, e.h * 0.08);
    ctx.lineTo(-e.w * 0.65, e.h * 0.18);
    ctx.stroke();
    // Right wing X mark
    ctx.beginPath();
    ctx.moveTo(e.w * 0.65, e.h * 0.08);
    ctx.lineTo(e.w * 0.5, e.h * 0.18);
    ctx.moveTo(e.w * 0.5, e.h * 0.08);
    ctx.lineTo(e.w * 0.65, e.h * 0.18);
    ctx.stroke();

    // Boss weapon pods on nose
    ctx.fillStyle = '#3a0a0a';
    ctx.fillRect(-4, e.h / 2 + 4, 3, 6);
    ctx.fillRect(1, e.h / 2 + 4, 3, 6);

    // HP bar
    const hpW = e.w * 2;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-hpW / 2, -e.h / 2 - 18, hpW, 8);
    ctx.strokeStyle = 'rgba(255,60,60,0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(-hpW / 2, -e.h / 2 - 18, hpW, 8);
    const hpRatio = e.hp / e.maxHp;
    const hpColor = hpRatio > 0.5 ? '#cc3333' : hpRatio > 0.2 ? '#ff6600' : '#ff0000';
    ctx.fillStyle = hpColor;
    ctx.fillRect(-hpW / 2 + 1, -e.h / 2 - 17, (hpW - 2) * hpRatio, 6);
    // "BOSS" text
    ctx.font = 'bold 8px monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,200,200,0.7)';
    ctx.fillText('BOSS', 0, -e.h / 2 - 22);

  } else if (e.type === 'basic') {
    // Basic enemy - small dark fighter, pointing down
    const bf = Math.sin(t * 4) * 0.3 + 0.7;
    // Engine flame on top
    const efH = 6 + Math.sin(t * 5) * 3;
    ctx.beginPath();
    ctx.moveTo(-3, -e.h / 2);
    ctx.lineTo(0, -e.h / 2 - efH);
    ctx.lineTo(3, -e.h / 2);
    ctx.fillStyle = `rgba(255,80,30,${bf * 0.6})`;
    ctx.fill();

    // Wings (angular, aggressive)
    ctx.beginPath();
    ctx.moveTo(-4, -e.h * 0.1);
    ctx.lineTo(-e.w * 0.9, e.h * 0.15);
    ctx.lineTo(-e.w * 0.7, e.h * 0.25);
    ctx.lineTo(-5, e.h * 0.1);
    ctx.closePath();
    ctx.fillStyle = '#2a1515';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,80,60,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(4, -e.h * 0.1);
    ctx.lineTo(e.w * 0.9, e.h * 0.15);
    ctx.lineTo(e.w * 0.7, e.h * 0.25);
    ctx.lineTo(5, e.h * 0.1);
    ctx.closePath();
    ctx.fillStyle = '#2a1515';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,80,60,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Body (pointing down)
    ctx.beginPath();
    ctx.moveTo(0, e.h / 2 + 2);
    ctx.lineTo(-6, e.h * 0.1);
    ctx.lineTo(-8, -e.h * 0.2);
    ctx.lineTo(-5, -e.h / 2);
    ctx.lineTo(5, -e.h / 2);
    ctx.lineTo(8, -e.h * 0.2);
    ctx.lineTo(6, e.h * 0.1);
    ctx.closePath();
    const bGrad = ctx.createLinearGradient(-8, 0, 8, 0);
    bGrad.addColorStop(0, '#1a0808');
    bGrad.addColorStop(0.5, '#4a1a1a');
    bGrad.addColorStop(1, '#1a0808');
    ctx.fillStyle = bGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,60,40,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Red cockpit light
    ctx.beginPath();
    ctx.arc(0, e.h * 0.15, 3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,30,20,${0.6 + Math.sin(t * 3) * 0.3})`;
    ctx.fill();

  } else if (e.type === 'fast') {
    // Fast enemy - sleek dart shape, more orange/yellow threat colors
    const ff = Math.sin(t * 5) * 0.3 + 0.7;
    // Engine
    const efH = 8 + Math.sin(t * 7) * 4;
    ctx.beginPath();
    ctx.moveTo(-2, -e.h / 2);
    ctx.lineTo(0, -e.h / 2 - efH);
    ctx.lineTo(2, -e.h / 2);
    ctx.fillStyle = `rgba(255,150,30,${ff * 0.7})`;
    ctx.fill();

    // Sharp swept wings
    ctx.beginPath();
    ctx.moveTo(-3, e.h * 0.05);
    ctx.lineTo(-e.w, e.h * 0.2);
    ctx.lineTo(-e.w * 0.6, e.h * 0.3);
    ctx.lineTo(-4, e.h * 0.15);
    ctx.closePath();
    ctx.fillStyle = '#3a2008';
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3, e.h * 0.05);
    ctx.lineTo(e.w, e.h * 0.2);
    ctx.lineTo(e.w * 0.6, e.h * 0.3);
    ctx.lineTo(4, e.h * 0.15);
    ctx.closePath();
    ctx.fillStyle = '#3a2008';
    ctx.fill();

    // Narrow dart body
    ctx.beginPath();
    ctx.moveTo(0, e.h / 2 + 4);
    ctx.lineTo(-4, e.h * 0.1);
    ctx.lineTo(-6, -e.h * 0.3);
    ctx.lineTo(-3, -e.h / 2);
    ctx.lineTo(3, -e.h / 2);
    ctx.lineTo(6, -e.h * 0.3);
    ctx.lineTo(4, e.h * 0.1);
    ctx.closePath();
    const fGrad = ctx.createLinearGradient(-6, 0, 6, 0);
    fGrad.addColorStop(0, '#1a0d00');
    fGrad.addColorStop(0.5, '#5a3010');
    fGrad.addColorStop(1, '#1a0d00');
    ctx.fillStyle = fGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,160,40,0.35)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Orange eye
    ctx.beginPath();
    ctx.arc(0, e.h * 0.15, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,180,30,${0.7 + Math.sin(t * 4) * 0.3})`;
    ctx.fill();

  } else if (e.type === 'tank') {
    // Tank - heavy armored bomber, wide and bulky, dark purple/black
    const tf = Math.sin(t * 2.5) * 0.3 + 0.7;
    // Twin engines
    const efH = 8 + Math.sin(t * 4) * 4;
    ctx.beginPath();
    ctx.moveTo(-10, -e.h / 2);
    ctx.lineTo(-8, -e.h / 2 - efH);
    ctx.lineTo(-6, -e.h / 2);
    ctx.fillStyle = `rgba(200,50,255,${tf * 0.5})`;
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(6, -e.h / 2);
    ctx.lineTo(8, -e.h / 2 - efH);
    ctx.lineTo(10, -e.h / 2);
    ctx.fillStyle = `rgba(200,50,255,${tf * 0.5})`;
    ctx.fill();

    // Heavy wide wings
    ctx.beginPath();
    ctx.moveTo(-10, -e.h * 0.15);
    ctx.lineTo(-e.w * 0.95, 0);
    ctx.lineTo(-e.w * 0.9, e.h * 0.15);
    ctx.lineTo(-e.w * 0.5, e.h * 0.12);
    ctx.lineTo(-10, e.h * 0.05);
    ctx.closePath();
    ctx.fillStyle = '#1a0a2a';
    ctx.fill();
    ctx.strokeStyle = 'rgba(160,60,220,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(10, -e.h * 0.15);
    ctx.lineTo(e.w * 0.95, 0);
    ctx.lineTo(e.w * 0.9, e.h * 0.15);
    ctx.lineTo(e.w * 0.5, e.h * 0.12);
    ctx.lineTo(10, e.h * 0.05);
    ctx.closePath();
    ctx.fillStyle = '#1a0a2a';
    ctx.fill();
    ctx.strokeStyle = 'rgba(160,60,220,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Thick armored body
    ctx.beginPath();
    ctx.moveTo(0, e.h / 2 + 3);
    ctx.lineTo(-7, e.h * 0.2);
    ctx.lineTo(-14, -e.h * 0.15);
    ctx.lineTo(-12, -e.h / 2);
    ctx.lineTo(12, -e.h / 2);
    ctx.lineTo(14, -e.h * 0.15);
    ctx.lineTo(7, e.h * 0.2);
    ctx.closePath();
    const tGrad = ctx.createLinearGradient(-14, 0, 14, 0);
    tGrad.addColorStop(0, '#0a0515');
    tGrad.addColorStop(0.3, '#2a1540');
    tGrad.addColorStop(0.5, '#3a1a55');
    tGrad.addColorStop(0.7, '#2a1540');
    tGrad.addColorStop(1, '#0a0515');
    ctx.fillStyle = tGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(180,80,255,0.4)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Armor plates detail
    ctx.beginPath();
    ctx.moveTo(-10, -e.h * 0.3);
    ctx.lineTo(10, -e.h * 0.3);
    ctx.strokeStyle = 'rgba(120,50,180,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-8, e.h * 0.05);
    ctx.lineTo(8, e.h * 0.05);
    ctx.stroke();

    // Purple menacing cockpit
    ctx.beginPath();
    ctx.ellipse(0, e.h * 0.1, 5, 4, 0, 0, Math.PI * 2);
    const tEyeGrad = ctx.createRadialGradient(0, e.h * 0.1, 1, 0, e.h * 0.1, 5);
    tEyeGrad.addColorStop(0, `rgba(255,150,255,${0.8 + Math.sin(t * 2) * 0.2})`);
    tEyeGrad.addColorStop(1, 'rgba(100,20,160,0.5)');
    ctx.fillStyle = tEyeGrad;
    ctx.fill();

    // HP bar
    const hpW = e.w + 14;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(-hpW / 2, -e.h / 2 - 12, hpW, 5);
    ctx.fillStyle = 'rgba(180,60,255,0.8)';
    ctx.fillRect(-hpW / 2, -e.h / 2 - 12, hpW * (e.hp / e.maxHp), 5);

  } else if (e.type === 'shooter') {
    // Shooter - tactical enemy with visible guns, dark green military
    const sf = Math.sin(t * 3) * 0.3 + 0.7;
    // Engine
    const efH = 7 + Math.sin(t * 5) * 3;
    ctx.beginPath();
    ctx.moveTo(-3, -e.h / 2);
    ctx.lineTo(0, -e.h / 2 - efH);
    ctx.lineTo(3, -e.h / 2);
    ctx.fillStyle = `rgba(100,255,80,${sf * 0.5})`;
    ctx.fill();

    // Angular wings
    ctx.beginPath();
    ctx.moveTo(-5, -e.h * 0.05);
    ctx.lineTo(-e.w * 0.85, e.h * 0.05);
    ctx.lineTo(-e.w * 0.8, e.h * 0.18);
    ctx.lineTo(-6, e.h * 0.1);
    ctx.closePath();
    ctx.fillStyle = '#0a1a08';
    ctx.fill();
    ctx.strokeStyle = 'rgba(60,200,60,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(5, -e.h * 0.05);
    ctx.lineTo(e.w * 0.85, e.h * 0.05);
    ctx.lineTo(e.w * 0.8, e.h * 0.18);
    ctx.lineTo(6, e.h * 0.1);
    ctx.closePath();
    ctx.fillStyle = '#0a1a08';
    ctx.fill();
    ctx.strokeStyle = 'rgba(60,200,60,0.25)';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Gun pods on wing tips
    ctx.fillStyle = '#1a2a10';
    ctx.fillRect(-e.w * 0.8 - 2, e.h * 0.05, 4, 10);
    ctx.fillRect(e.w * 0.8 - 2, e.h * 0.05, 4, 10);
    // Gun barrel flash
    ctx.beginPath();
    ctx.arc(-e.w * 0.8, e.h * 0.05 + 12, 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,100,${Math.sin(t * 6) > 0.5 ? 0.6 : 0.1})`;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(e.w * 0.8, e.h * 0.05 + 12, 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,100,${Math.sin(t * 6 + 1) > 0.5 ? 0.6 : 0.1})`;
    ctx.fill();

    // Body
    ctx.beginPath();
    ctx.moveTo(0, e.h / 2 + 3);
    ctx.lineTo(-5, e.h * 0.15);
    ctx.lineTo(-9, -e.h * 0.2);
    ctx.lineTo(-6, -e.h / 2);
    ctx.lineTo(6, -e.h / 2);
    ctx.lineTo(9, -e.h * 0.2);
    ctx.lineTo(5, e.h * 0.15);
    ctx.closePath();
    const sGrad = ctx.createLinearGradient(-9, 0, 9, 0);
    sGrad.addColorStop(0, '#050d04');
    sGrad.addColorStop(0.5, '#1a3515');
    sGrad.addColorStop(1, '#050d04');
    ctx.fillStyle = sGrad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(80,200,60,0.35)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Green targeting cockpit
    ctx.beginPath();
    ctx.arc(0, e.h * 0.1, 3.5, 0, Math.PI * 2);
    const sEyeGrad = ctx.createRadialGradient(0, e.h * 0.1, 0.5, 0, e.h * 0.1, 3.5);
    sEyeGrad.addColorStop(0, `rgba(200,255,100,${0.8 + Math.sin(t * 3) * 0.2})`);
    sEyeGrad.addColorStop(1, 'rgba(30,100,20,0.5)');
    ctx.fillStyle = sEyeGrad;
    ctx.fill();

    // HP bar for shooter since hp > 1
    if (e.maxHp > 1) {
      const hpW = e.w + 10;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(-hpW / 2, -e.h / 2 - 10, hpW, 4);
      ctx.fillStyle = 'rgba(80,220,60,0.8)';
      ctx.fillRect(-hpW / 2, -e.h / 2 - 10, hpW * (e.hp / e.maxHp), 4);
    }
  }

  ctx.restore();
}

function drawBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);
  const grad = ctx.createLinearGradient(0, -b.h / 2, 0, b.h / 2);
  grad.addColorStop(0, '#fff');
  grad.addColorStop(0.5, b.color);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);

  ctx.shadowColor = b.color;
  ctx.shadowBlur = 8;
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.fillRect(-b.w / 4, -b.h / 2, b.w / 2, b.h / 3);
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawEnemyBullet(b) {
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.beginPath();
  ctx.arc(0, 0, b.r || 4, 0, Math.PI * 2);
  ctx.fillStyle = '#ff5555';
  ctx.fill();
  ctx.shadowColor = '#ff3333';
  ctx.shadowBlur = 10;
  ctx.beginPath();
  ctx.arc(0, 0, (b.r || 4) * 0.5, 0, Math.PI * 2);
  ctx.fillStyle = '#ffaaaa';
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawItem(item) {
  ctx.save();
  ctx.translate(item.x, item.y);
  item.pulse += 0.08;
  const scale = 1 + Math.sin(item.pulse) * 0.1;
  ctx.scale(scale, scale);

  let emoji, bgColor;
  switch (item.type) {
    case 'weapon': emoji = 'üî´'; bgColor = 'rgba(50,150,255,0.3)'; break;
    case 'bomb': emoji = 'üí£'; bgColor = 'rgba(255,100,50,0.3)'; break;
    case 'score': emoji = '‚≠ê'; bgColor = 'rgba(255,200,50,0.3)'; break;
    case 'heal': emoji = '‚ù§Ô∏è'; bgColor = 'rgba(255,50,80,0.3)'; break;
  }

  ctx.beginPath();
  ctx.arc(0, 0, 16, 0, Math.PI * 2);
  ctx.fillStyle = bgColor;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.font = '18px serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(emoji, 0, 0);

  ctx.restore();
}

function drawBackground(dt) {
  // Dark gradient sky
  const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
  skyGrad.addColorStop(0, '#040810');
  skyGrad.addColorStop(0.5, '#0a1628');
  skyGrad.addColorStop(1, '#0c1a30');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  stars.forEach(s => {
    s.y += s.speed * (dt / 16);
    if (s.y > H + 10) { s.y = -10; s.x = Math.random() * W; }
    if (s.x > W) s.x -= W;
    ctx.beginPath();
    ctx.arc(s.x % W, s.y, s.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(200,220,255,${s.brightness})`;
    ctx.fill();
  });

  // Clouds
  clouds.forEach(c => {
    c.y += c.speed * (dt / 16);
    if (c.y > H + 60) { c.y = -80; c.x = Math.random() * W; }
    ctx.fillStyle = `rgba(100,140,180,${c.alpha})`;
    ctx.beginPath();
    ctx.ellipse(c.x % W, c.y, c.w / 2, c.h / 2, 0, 0, Math.PI * 2);
    ctx.fill();
  });
}

// Collision detection
function rectCollide(a, b) {
  return Math.abs(a.x - b.x) < (a.w + b.w) / 2 &&
         Math.abs(a.y - b.y) < (a.h + b.h) / 2;
}

function circleCollide(a, b, ar, br) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx * dx + dy * dy < (ar + br) * (ar + br);
}

// HUD
function updateHUD() {
  document.getElementById('hud-score').textContent = score.toLocaleString();

  const livesEl = document.getElementById('hud-lives');
  livesEl.innerHTML = '';
  for (let i = 0; i < player.lives; i++) {
    const s = document.createElement('span');
    s.textContent = '‚úàÔ∏è';
    livesEl.appendChild(s);
  }

  const bombsEl = document.getElementById('hud-bombs');
  bombsEl.innerHTML = '';
  for (let i = 0; i < player.bombs; i++) {
    const s = document.createElement('span');
    s.textContent = 'üí£';
    bombsEl.appendChild(s);
  }

  const w = WEAPONS[player.weaponLevel];
  document.getElementById('hud-weapon').textContent = w.name;
  document.getElementById('hud-weapon').style.color = w.color;
}

// Game update
function update(dt) {
  if (gameState !== STATE.PLAYING) return;
  gameTime += dt;
  difficulty = 1 + Math.floor(gameTime / 15000);

  // Player movement
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['KeyA'] || mobileDir.left) dx = -1;
  if (keys['ArrowRight'] || keys['KeyD'] || mobileDir.right) dx = 1;
  if (keys['ArrowUp'] || keys['KeyW'] || mobileDir.up) dy = -1;
  if (keys['ArrowDown'] || keys['KeyS'] || mobileDir.down) dy = 1;

  if (dx !== 0 && dy !== 0) {
    dx *= 0.707; dy *= 0.707;
  }

  player.x += dx * player.speed * (dt / 16);
  player.y += dy * player.speed * (dt / 16);
  player.x = Math.max(player.w, Math.min(W - player.w, player.x));
  player.y = Math.max(player.h, Math.min(H - player.h / 2, player.y));
  player.tilt += (dx * 3 - player.tilt) * 0.1;

  // Auto-fire
  player.fireTimer -= dt;
  const w = WEAPONS[player.weaponLevel];
  if (player.fireTimer <= 0) {
    fireBullets();
    player.fireTimer = w.fireRate;
  }

  // Invincibility timer
  if (player.invincible) {
    player.invincibleTimer -= dt;
    if (player.invincibleTimer <= 0) {
      player.invincible = false;
    }
  }

  // Update bullets
  bullets.forEach(b => { b.x += b.vx * (dt / 16); b.y += b.vy * (dt / 16); });
  bullets = bullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Update enemy bullets
  enemyBullets.forEach(b => { b.x += b.vx * (dt / 16); b.y += b.vy * (dt / 16); });
  enemyBullets = enemyBullets.filter(b => b.y > -20 && b.y < H + 20 && b.x > -20 && b.x < W + 20);

  // Spawn enemies
  spawnEnemies(dt);

  // Update enemies
  enemies.forEach(e => {
    e.moveTimer += dt * 0.003;
    switch (e.movePattern) {
      case 'straight':
        e.y += e.speed * (dt / 16);
        break;
      case 'zigzag':
        e.y += e.speed * (dt / 16);
        e.x += Math.sin(e.moveTimer) * 2.5;
        break;
      case 'boss':
        if (e.y < 80) {
          e.y += e.speed * (dt / 16);
        }
        e.x = W / 2 + Math.sin(e.moveTimer * 0.5) * (W / 3);
        break;
    }

    // Enemy shooting
    if (e.fireRate > 0) {
      e.fireTimer -= dt;
      if (e.fireTimer <= 0 && e.y > 0) {
        e.fireTimer = e.fireRate;
        if (e.type === 'boss') {
          // Boss fires spread
          for (let i = -2; i <= 2; i++) {
            const angle = Math.PI / 2 + i * 0.25;
            enemyBullets.push({
              x: e.x, y: e.y + e.h / 2,
              vx: Math.cos(angle) * 3.5,
              vy: Math.sin(angle) * 3.5,
              r: 5
            });
          }
        } else {
          const angle = Math.atan2(player.y - e.y, player.x - e.x);
          enemyBullets.push({
            x: e.x, y: e.y + e.h / 2,
            vx: Math.cos(angle) * 3,
            vy: Math.sin(angle) * 3,
            r: 4
          });
        }
      }
    }
  });
  enemies = enemies.filter(e => e.y < H + 100);

  // Bullet-enemy collision
  for (let i = bullets.length - 1; i >= 0; i--) {
    for (let j = enemies.length - 1; j >= 0; j--) {
      if (rectCollide(bullets[i], enemies[j])) {
        enemies[j].hp -= bullets[i].damage;
        // Hit particles
        for (let k = 0; k < 3; k++) {
          particles.push({
            x: bullets[i].x, y: bullets[i].y,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            life: 15, maxLife: 15,
            size: 2, color: bullets[i].color
          });
        }
        bullets.splice(i, 1);

        if (enemies[j].hp <= 0) {
          const e = enemies[j];
          createExplosion(e.x, e.y, e.w);
          score += e.score;
          kills++;
          if (Math.random() < 0.25) spawnItem(e.x, e.y);
          enemies.splice(j, 1);
          screenShake = Math.max(screenShake, 3);
          updateHUD();
        }
        break;
      }
    }
  }

  // Enemy bullet - player collision
  if (!player.invincible) {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      if (circleCollide(enemyBullets[i], player, enemyBullets[i].r, 14)) {
        enemyBullets.splice(i, 1);
        playerHit();
        break;
      }
    }
  }

  // Enemy-player collision
  if (!player.invincible) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      if (rectCollide(enemies[i], { x: player.x, y: player.y, w: player.w * 0.7, h: player.h * 0.7 })) {
        createExplosion(enemies[i].x, enemies[i].y, enemies[i].w);
        enemies.splice(i, 1);
        playerHit();
        break;
      }
    }
  }

  // Item pickup
  for (let i = items.length - 1; i >= 0; i--) {
    items[i].y += items[i].vy * (dt / 16);
    items[i].life -= dt / 16;
    if (items[i].life <= 0 || items[i].y > H + 30) {
      items.splice(i, 1);
      continue;
    }
    if (circleCollide(items[i], player, 16, 20)) {
      const item = items[i];
      switch (item.type) {
        case 'weapon':
          if (player.weaponLevel < 5) {
            player.weaponLevel++;
            showFloatingText(player.x, player.y - 40, WEAPONS[player.weaponLevel].name + '!', WEAPONS[player.weaponLevel].color);
          } else {
            score += 500;
            showFloatingText(player.x, player.y - 40, '+500', '#ffd700');
          }
          break;
        case 'bomb':
          player.bombs = Math.min(player.bombs + 1, 8);
          showFloatingText(player.x, player.y - 40, 'Ìè≠ÌÉÑ +1!', '#ff6b35');
          break;
        case 'score':
          score += 300;
          showFloatingText(player.x, player.y - 40, '+300', '#ffd700');
          break;
        case 'heal':
          player.lives = Math.min(player.lives + 1, 5);
          showFloatingText(player.x, player.y - 40, 'ÏÉùÎ™Ö +1!', '#ff4466');
          break;
      }
      items.splice(i, 1);
      updateHUD();
    }
  }

  // Update particles
  particles.forEach(p => {
    p.x += p.vx * (dt / 16);
    p.y += p.vy * (dt / 16);
    p.life -= dt / 16;
    p.vx *= 0.98;
    p.vy *= 0.98;
  });
  particles = particles.filter(p => p.life > 0);

  // Update explosions
  explosions.forEach(ex => {
    ex.life -= ex.speed * (dt / 16);
    ex.radius += 2 * (dt / 16);
  });
  explosions = explosions.filter(ex => ex.life > 0);

  // Update screen effects
  if (screenShake > 0) screenShake *= 0.9;
  if (screenShake < 0.1) screenShake = 0;
  if (bombFlash > 0) bombFlash -= 0.03 * (dt / 16);
  if (damageFlash > 0) damageFlash -= 0.04 * (dt / 16);

  // Update floating texts
  floatingTexts.forEach(ft => {
    ft.y -= 1 * (dt / 16);
    ft.life -= dt / 16;
  });
  floatingTexts = floatingTexts.filter(ft => ft.life > 0);
}

function playerHit() {
  player.lives--;
  screenShake = 10;
  damageFlash = 1;
  createExplosion(player.x, player.y, 20);
  updateHUD();

  if (player.lives <= 0) {
    gameOver();
  } else {
    player.invincible = true;
    player.invincibleTimer = 2000;
    if (player.weaponLevel > 1) player.weaponLevel--;
  }
}

let floatingTexts = [];
function showFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 60 });
}

function gameOver() {
  gameState = STATE.GAMEOVER;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('skyFighterHigh', highScore.toString());
  }
  document.getElementById('final-score').textContent = score.toLocaleString();
  document.getElementById('final-stats').textContent =
    `Í≤©Ï∂î: ${kills}ÎåÄ | ÏÉùÏ°¥ÏãúÍ∞Ñ: ${Math.floor(gameTime / 1000)}Ï¥à | ÏµúÍ≥†Ï†êÏàò: ${highScore.toLocaleString()}`;
  document.getElementById('gameover-screen').classList.remove('hidden');
  document.getElementById('hud').classList.add('hidden');
}

function startGame() {
  gameState = STATE.PLAYING;
  score = 0; kills = 0; gameTime = 0; difficulty = 1; waveCount = 0;
  bullets = []; enemyBullets = []; enemies = []; particles = [];
  items = []; explosions = []; floatingTexts = [];
  screenShake = 0; bombFlash = 0; damageFlash = 0;
  enemySpawnTimer = 1000;

  initPlayer();

  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('gameover-screen').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  updateHUD();
}

// Draw loop
function draw() {
  ctx.save();

  // Screen shake
  if (screenShake > 0) {
    ctx.translate(
      (Math.random() - 0.5) * screenShake * 2,
      (Math.random() - 0.5) * screenShake * 2
    );
  }

  drawBackground(16);

  if (gameState === STATE.PLAYING || gameState === STATE.GAMEOVER) {
    // Draw items
    items.forEach(item => drawItem(item));

    // Draw bullets
    bullets.forEach(b => drawBullet(b));

    // Draw enemy bullets
    enemyBullets.forEach(b => drawEnemyBullet(b));

    // Draw enemies
    enemies.forEach(e => drawEnemy(e));

    // Draw player
    if (gameState === STATE.PLAYING) {
      if (player.invincible && player.invincibleTimer < 1000) {
        if (Math.floor(Date.now() / 80) % 2 === 0) drawPlayer();
      } else {
        drawPlayer();
      }
    }

    // Draw explosions
    explosions.forEach(ex => {
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,200,50,${ex.life * 0.4})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.radius * 0.6, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,200,${ex.life * 0.6})`;
      ctx.fill();
    });

    // Draw particles
    particles.forEach(p => {
      const alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    // Draw floating texts
    floatingTexts.forEach(ft => {
      const alpha = ft.life / 60;
      ctx.font = 'bold 16px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = ft.color;
      ctx.globalAlpha = alpha;
      ctx.fillText(ft.text, ft.x, ft.y);
      ctx.globalAlpha = 1;
    });

    // Bomb flash
    if (bombFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${bombFlash * 0.5})`;
      ctx.fillRect(-50, -50, W + 100, H + 100);
    }

    // Damage flash
    if (damageFlash > 0) {
      ctx.fillStyle = `rgba(255,0,0,${damageFlash * 0.3})`;
      ctx.fillRect(-50, -50, W + 100, H + 100);
    }
  }

  ctx.restore();
}

// Game loop
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = Math.min(timestamp - lastTime, 33);
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

// Event listeners
document.getElementById('btn-start').addEventListener('click', startGame);
document.getElementById('btn-restart').addEventListener('click', startGame);

// Keyboard start
window.addEventListener('keydown', e => {
  if (e.code === 'Enter' || e.code === 'Space') {
    if (gameState === STATE.MENU) startGame();
    else if (gameState === STATE.GAMEOVER) startGame();
  }
});

// Initialize
initPlayer();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
